# AiRword æŒ–çŸ¿ã€å‘è¡Œã€é”ä»“ã€é¢†å–ä¸ç¢ç‰‡å…‘æ¢æœºåˆ¶

## æŠ€æœ¯è®¾è®¡ä¸æ‰§è¡Œè¯´æ˜æ–‡æ¡£ï¼ˆç»ˆç‰ˆ Â· å…¨é‡ï¼‰

---

# ç¬¬ä¸€éƒ¨åˆ†ï¼šç³»ç»Ÿæ€»è§ˆï¼ˆå…¨å±€è§†è§’ï¼‰

## 1. ç³»ç»Ÿè§£å†³çš„é—®é¢˜æ˜¯ä»€ä¹ˆ

åœ¨ä¸€ä¸ª **æ€»é‡æ’å®šï¼ˆCAP = 2.1 äº¿ï¼‰** çš„å‰æä¸‹ï¼Œæ„å»ºä¸€ä¸ªï¼š

* ä¸å¯è¶…å‘
* ä¸ä¾èµ–å®šæ—¶å™¨
* å¯è·¨å¹´è¡¥å¿ç»“ç®—
* å¯å®¡è®¡ã€å¯è¯æ˜
* åŒæ—¶æ”¯æŒ **é”ä»“é‡Šæ”¾ + ç¢ç‰‡é‡‘èåŒ–**

çš„é•¿æœŸæŒ–çŸ¿å‘è¡Œç³»ç»Ÿã€‚

---

## 2. ç³»ç»Ÿçš„æ ¸å¿ƒæ€æƒ³ï¼ˆéå¸¸é‡è¦ï¼‰

> **æŒ–çŸ¿ â‰  ç›´æ¥é“¸å¸**

ç³»ç»Ÿä¸­çš„â€œæŒ–çŸ¿â€åˆ†ä¸ºä¸‰å±‚å«ä¹‰ï¼š

1. **å¹´åº¦å±‚**ï¼šå†³å®šä¸€å¹´æœ€å¤šèƒ½é‡Šæ”¾å¤šå°‘å‘è¡Œé¢åº¦
2. **æ—¥å±‚**ï¼šæŠŠå¹´åº¦é¢åº¦å‡åŒ€æ‘Šåˆ°æ¯å¤©
3. **æ‰§è¡Œå±‚**ï¼šæŠŠå½“æ—¥ç¡®è®¤çš„å‘è¡Œé¢åº¦ â†’ è®°è´¦è¿›å…¥é”ä»“

ğŸ‘‰ **çœŸæ­£å‘ç”Ÿ `_mint` çš„æ—¶é—´ç‚¹ï¼Œåªæœ‰ä¸€ä¸ªï¼šé¢†å–ï¼ˆclaimï¼‰**
> ä¾‹å¤–ï¼š
> 1) éƒ¨ç½²/åˆå§‹åŒ–é˜¶æ®µçš„**åˆå§‹åˆ†é… 10%** å…è®¸ `_mint`
> 2) `allocateEmissionToLocks` åœ¨ `distType = 2` æ—¶å…è®¸**ç›´æ¥åˆ†å‘ `_mint`**ã€‚

---

## 3. æ¨¡å—åˆ’åˆ†ï¼ˆé€»è¾‘è§£è€¦ï¼‰

ç³»ç»Ÿç”± 6 ä¸ªæ¨¡å—ç»„æˆï¼š

1. åˆå§‹åŒ–ä¸å¯åŠ¨æ¨¡å—
2. å¹´åº¦å‘è¡Œæ§åˆ¶æ¨¡å—
3. æ—¥å‘è¡Œé¢åº¦è®¡ç®—æ¨¡å—
4. æŒ–çŸ¿åˆ†å‘ï¼ˆå…¥ä»“ï¼‰æ¨¡å—
5. é”ä»“ç³»ç»Ÿï¼ˆL1 / L2 / L3ï¼‰
6. é¢†å–ä¸ç¢ç‰‡å…‘æ¢æ¨¡å—

---

# ç¬¬äºŒéƒ¨åˆ†ï¼šç”Ÿå‘½å‘¨æœŸä¸å‘è¡Œæ§åˆ¶

---

## ä¸€ã€æ•´ä½“ç”Ÿå‘½å‘¨æœŸæµç¨‹ï¼ˆéƒ¨ç½² â†’ å¯åŠ¨æŒ–çŸ¿ï¼‰

### æ–‡å­—è¯´æ˜ï¼ˆä¸¥æ ¼æ‰§è¡Œé¡ºåºï¼‰

### 1ï¸âƒ£ åˆçº¦éƒ¨ç½²é˜¶æ®µ

* åˆçº¦éƒ¨ç½²å®Œæˆ
* åˆå§‹åŒ–ä»¥ä¸‹ä¸å¯å˜æˆ–ä¸€æ¬¡æ€§å˜é‡ï¼š

```text
CAP = 210,000,000
```

### 2ï¸âƒ£ åˆå§‹åˆ†é…é˜¶æ®µï¼ˆä¸å‚ä¸æŒ–çŸ¿ï¼‰

* 4% åˆ†é…ç»™ **åˆçº¦åœ°å€**
* 6% åˆ†é…ç»™ **ç¤¾åŒºåœ°å€**

```text
initialAllocated = CAP * 10%
remainingCap = CAP - initialAllocated
```

> âš ï¸ æ³¨æ„ï¼š
> `remainingCap` æ˜¯ **æ•´ä¸ªæŒ–çŸ¿ç³»ç»Ÿæœªæ¥æ‰€æœ‰å¹´ä»½å”¯ä¸€çš„ç‡ƒæ–™æ± **

---

### 3ï¸âƒ£ å¯åŠ¨æŒ–çŸ¿ï¼ˆæ˜¾å¼è§¦å‘ï¼‰

åˆçº¦ä¸ä¼šè‡ªåŠ¨å¼€å§‹æŒ–çŸ¿ï¼Œå¿…é¡»è°ƒç”¨ï¼š

```solidity
startMining()
```

è¯¥æ–¹æ³•åªåšä¸€ä»¶äº‹ï¼š

```text
miningStart = block.timestamp
```

ç”±æ­¤ï¼š

* æ‰€æœ‰â€œç¬¬å‡ å¹´ / ç¬¬å‡ å¤©â€çš„è®¡ç®—å…¨éƒ¨åŸºäºè¯¥æ—¶é—´
* åœ¨æ­¤ä¹‹å‰ï¼Œæ‰€æœ‰æŒ–çŸ¿ã€æŸ¥è¯¢è¡Œä¸ºéƒ½ä¸å¯æ‰§è¡Œ

---

### å¯¹åº”æµç¨‹å›¾

```mermaid
flowchart TD
    A["deployï½œéƒ¨ç½²åˆçº¦"] --> B["initï½œåˆå§‹åŒ– CAP = 210,000,000"]
    B --> C["allocateï½œ4% â†’ åˆçº¦åœ°å€"]
    C --> D["allocateï½œ6% â†’ ç¤¾åŒºåœ°å€"]
    D --> E["calcï½œremainingCap = CAP - 10%"]
    E --> F["waitï½œç­‰å¾… startMining()"]
    F --> G["setï½œminingStart = now"]
    G --> H["enterï½œè¿›å…¥ç¬¬ 1 å¹´æŒ–çŸ¿å‘¨æœŸ"]
```

---

# ç¬¬ä¸‰éƒ¨åˆ†ï¼šå¹´åº¦å‘è¡Œä¸ç»“ç®—ï¼ˆç³»ç»Ÿæ ¸å¿ƒï¼‰

---

## äºŒã€å¹´åº¦ç»“ç®—æœºåˆ¶ï¼ˆé˜²é”™æ ¸å¿ƒï¼‰

### 1. ä¸ºä»€ä¹ˆå¿…é¡»æ˜¾å¼ç»“ç®—

åŒºå—é“¾ä¸ä¼šâ€œè‡ªåŠ¨åˆ°å¹´æœ«â€ï¼Œå› æ­¤ï¼š

> **æ¯ä¸€æ¬¡ä¸å‘è¡Œç›¸å…³çš„æ“ä½œå‰ï¼Œå¿…é¡»æ£€æŸ¥æ˜¯å¦å·²ç»è·¨å¹´**

---

### 2. å¹´åº¦æ ¸å¿ƒå˜é‡è¯´æ˜

| å˜é‡å             | å«ä¹‰              |
| --------------- | --------------- |
| miningStart     | æŒ–çŸ¿èµ·å§‹æ—¶é—´          |
| currentYear     | å½“å‰å¤„äºç¬¬å‡ å¹´ï¼ˆä» 1 å¼€å§‹ï¼‰ |
| lastSettledYear | å·²å®Œæˆç»“ç®—çš„æœ€åä¸€å¹´      |
| yearBudget      | å½“å‰å¹´åº¦æœ€å¤§å‘è¡Œé¢åº¦      |
| yearMinted      | å½“å‰å¹´åº¦å·²åˆ†å‘é¢åº¦       |
| remainingCap    | å°šæœªåˆ†é…åˆ°ä»»ä½•æœªæ¥å¹´ä»½çš„æ€»é¢åº¦ |

---

### 3. å¹´åº¦ç»“ç®—è§¦å‘ç‚¹ï¼ˆéå¸¸é‡è¦ï¼‰

ä»¥ä¸‹æ‰€æœ‰è¡Œä¸º **å¿…é¡»å…ˆè°ƒç”¨**ï¼š

```solidity
settleToCurrentYear()
```

* allocateEmissionToLocks
* getTodayMintable
* ä»»ä½•å¹´åº¦ç»Ÿè®¡æŸ¥è¯¢

---

### 4. å¹´åº¦ç»“ç®—å®Œæ•´é€»è¾‘ï¼ˆé€æ­¥ï¼‰

#### Step 1ï¼šè®¡ç®—å½“å‰å¹´ä»½

```text
currentYear = floor((now - miningStart) / 365 days) + 1
```

---

#### Step 2ï¼šæ˜¯å¦éœ€è¦ç»“ç®—

```text
if currentYear <= lastSettledYear:
    return
```

---

#### Step 3ï¼šè·¨å¹´å¾ªç¯ç»“ç®—ï¼ˆå¯è¡¥å¿ï¼‰

```text
while lastSettledYear < currentYear:
```

æ¯ä¸€è½®å¾ªç¯ï¼Œç»“ç®— **ä¸€ä¸ªå®Œæ•´å¹´åº¦**ï¼š

1. è®¡ç®—æœªæŒ–å®Œé¢åº¦ï¼š

```text
unminted = yearBudget - yearMinted
```

2. ä»å‰©ä½™æ€»é‡ä¸­æ‰£é™¤ï¼ˆè§†ä¸ºé”€æ¯ï¼‰ï¼š

```text
remainingCap -= unminted
```

> âš ï¸ è¿™é‡Œé”€æ¯çš„æ˜¯ **å‘è¡Œé¢åº¦**ï¼Œä¸æ˜¯å·² mint çš„ä»£å¸

3. è®°å½•äº‹ä»¶ï¼š

```solidity
emit UnmintedAllocationBurned(year, unminted)
```

4. æ¨è¿›åˆ°ä¸‹ä¸€å¹´ï¼š

```text
lastSettledYear += 1
yearBudget = remainingCap / 2
yearMinted = 0
yearStartTs = æ–°å¹´åº¦èµ·å§‹æ—¶é—´
```

---

### å¯¹åº”æµç¨‹å›¾

```mermaid
flowchart TD
    A["beforeï½œæŒ–çŸ¿ / æŸ¥è¯¢å‰"] --> B["calcï½œcurrentYear"]
    B --> C{"currentYear > lastSettledYear ?"}
    C -- "å¦" --> Z["ç»§ç»­ä½¿ç”¨å½“å‰å¹´åº¦"]
    C -- "æ˜¯" --> D["loopï½œå¹´åº¦ç»“ç®—"]
    D --> E["calcï½œunminted = yearBudget - yearMinted"]
    E --> F["burnï½œremainingCap -= unminted"]
    F --> G["eventï½œè®°å½•é”€æ¯äº‹ä»¶"]
    G --> H["updateï½œlastSettledYear++"]
    H --> I["calcï½œyearBudget = remainingCap / 2"]
    I --> J["resetï½œyearMinted = 0"]
    J --> K["setï½œyearStartTs"]
    K --> B
```

---

# ç¬¬å››éƒ¨åˆ†ï¼šæ—¥å‘è¡Œé¢åº¦è®¡ç®—ï¼ˆç»™åç«¯ï¼‰

---

## ä¸‰ã€ä»Šæ—¥å¯å‘è¡Œé‡è®¡ç®—

### è®¾è®¡è¾¹ç•Œ

* åˆçº¦ **ä¸å…³å¿ƒçŸ¿æœºæ•°é‡**
* åˆçº¦åªå›ç­”ï¼š

> **â€œä»Šå¤©æœ€å¤šè¿˜èƒ½åˆ†å‘å¤šå°‘å‘è¡Œé¢åº¦ï¼Ÿâ€**

---

### è®¡ç®—æ­¥éª¤

1ï¸âƒ£ å¹´åº¦ç»“ç®—
2ï¸âƒ£ å¹´åº¦å‰©ä½™é¢åº¦ï¼š

```text
yearRemaining = yearBudget - yearMinted
```

3ï¸âƒ£ å·²è¿‡å»å¤©æ•°ï¼š

```text
daysPassed = floor((now - yearStartTs) / 1 day)
```

4ï¸âƒ£ å‰©ä½™å¤©æ•°ï¼š

```text
daysRemaining = 365 - daysPassed
```

5ï¸âƒ£ è¾¹ç•Œåˆ¤æ–­ï¼š

* è‹¥ `daysRemaining <= 0` â†’ è¿”å› 0

6ï¸âƒ£ ä»Šæ—¥å¯å‘è¡Œé¢åº¦ï¼š

```text
todayMintable = yearRemaining / daysRemaining
```

---

### å¯¹åº”æµç¨‹å›¾

```mermaid
flowchart TD
  A["callï½œgetTodayMintable()"] --> B["settleï½œå¹´åº¦ç»“ç®—"]
  B --> C["calcï½œyearRemaining"]
  C --> D["calcï½œdaysPassed"]
  D --> E["calcï½œdaysRemaining"]
  E --> F{"daysRemaining > 0 ?"}
  F -- "å¦" --> G["return 0"]
  F -- "æ˜¯" --> H["todayMintable = yearRemaining / daysRemaining"]
```

---

# ç¬¬äº”éƒ¨åˆ†ï¼šæŒ–çŸ¿æ‰§è¡Œï¼ˆåˆ†å‘å…¥ä»“ï¼‰

---

## å››ã€æŒ–çŸ¿æ‰§è¡Œçš„çœŸå®å«ä¹‰

> **æŒ–çŸ¿æ‰§è¡Œ = æŠŠå½“æ—¥ç¡®è®¤çš„å‘è¡Œé¢åº¦ï¼Œåˆ†é…è¿›å…¥é”ä»“æˆ–ç›´æ¥åˆ†å‘**

---

## äº”ã€åˆ†å‘æ¥å£ï¼ˆå·²å®šå‹ï¼‰

> åˆ†å‘å…¥ä»“æ—¶ **ç”±è°ƒç”¨æ–¹æŒ‡å®šä»“ä½**ï¼Œä¸å†è‡ªåŠ¨æ‹†åˆ†ã€‚

```solidity
allocateEmissionToLocks(address to, uint256 amount, uint8 lockType, uint8 distType, uint256 orderId)
```

### å…¥å‚è¯´æ˜

* `lockType = 1` â†’ L1ï¼ˆè§£é”æ—¶é—´ï¼šnow + 1 monthï¼‰
* `lockType = 2` â†’ L2ï¼ˆè§£é”æ—¶é—´ï¼šnow + 2 monthï¼‰
* `lockType = 3` â†’ L3ï¼ˆè§£é”æ—¶é—´ï¼šnow + 4 monthï¼‰
* `distType = 1` â†’ å…¥ä»“
* `distType = 2` â†’ ç›´æ¥åˆ†å‘ï¼ˆ**lockType å¿…é¡»ä¸º 0**ï¼‰
* `orderId` â†’ è®¢å•å·ï¼ˆ**æŒ‰ç”¨æˆ·å”¯ä¸€**ï¼Œå¯¹ `to` åœ°å€ç”Ÿæ•ˆï¼‰

---

### æ‰§è¡Œæ­¥éª¤ï¼ˆä¸¥æ ¼é¡ºåºï¼‰

1. å¹´åº¦ç»“ç®—
2. æ ¡éªŒå¹´åº¦ä¸Šé™ï¼š

```text
require(yearMinted + amount <= yearBudget)
```

3. æ‰£å‡å…¨å±€é¢åº¦ï¼š

```text
yearMinted += amount
remainingCap -= amount
```

4. æ ¡éªŒåˆ†å‘ç±»å‹ï¼š
    * `distType` å¿…é¡»ä¸º `1/2`
    * è‹¥ `distType = 2`ï¼Œ`lockType` å¿…é¡»ä¸º `0`
5. æ ¡éªŒè®¢å•å·ï¼š`orderId` åœ¨ `to` åœ°å€ä¸‹ä¸å¾—é‡å¤
6. æ ¹æ® `distType` æ‰§è¡Œï¼š
    * `distType = 1` â†’ æŒ‰ `lockType` å†™å…¥æŒ‡å®šé”ä»“
    * `distType = 2` â†’ **ç›´æ¥ `_mint` ç»™ç”¨æˆ·**ï¼ˆä¸å†™å…¥é”ä»“è®°å½•ï¼‰

* 1 â†’ L1ï¼šnow + 1 month
* 2 â†’ L2ï¼šnow + 2 month
* 3 â†’ L3ï¼šnow + 4 month

---

### å¯¹åº”æµç¨‹å›¾

```mermaid
flowchart TD
    A["backendï½œç®—å‡º amount"] --> B["callï½œallocateEmissionToLocks"]
    B --> C["settleï½œå¹´åº¦ç»“ç®—"]
    C --> D{"yearMinted + amount <= yearBudget ?"}
    D -- "å¦" --> X["revert"]
    D -- "æ˜¯" --> E["updateï½œyearMinted / remainingCap"]
    E --> F["selectï½œlockType"]
    F --> G["pushï½œL1(1)"]
    F --> H["pushï½œL2(2)"]
    F --> I["pushï½œL3(3)"]
```

---

# ç¬¬å…­éƒ¨åˆ†ï¼šé”ä»“ç³»ç»Ÿï¼ˆL1 / L2 / L3ï¼‰

---

## å…­ã€é”ä»“ç»“æ„å®šä¹‰

```text
LockRecord {
  time            // è§£é”æ—¶é—´æˆ³
  amount          // é¢åº¦
  claimStatus     // æ˜¯å¦å·²é¢†å–
  fragmentStatus  // æ˜¯å¦å·²å…‘æ¢ç¢ç‰‡
}
```

### çŠ¶æ€ä¸å˜é‡

```text
claimStatus == true â†’ fragmentStatus == false
fragmentStatus == true â†’ claimStatus == false
```

---

## ä¸ƒã€é”ä»“æŸ¥è¯¢èƒ½åŠ›ï¼ˆå¿…é¡»æ”¯æŒï¼‰

### å•ä»“ç»Ÿè®¡ç»´åº¦

| ç»Ÿè®¡é¡¹ | å«ä¹‰                    |
| --- | --------------------- |
| å¯é¢†å– | time <= now ä¸”æœªé¢†å–æœªå…‘æ¢   |
| æœªåˆ°æœŸ | time > now ä¸”æœªå…‘æ¢       |
| å·²é¢†å– | claimStatus = true    |
| å·²å…‘æ¢ | fragmentStatus = true |

---

### æŸ¥è¯¢æµç¨‹å›¾ï¼ˆé€šç”¨ï¼‰

```mermaid
flowchart TD
    A["éå†ä»“ Lx"] --> B{"time <= now ?"}
    B -- "æ˜¯" --> C{"claim / fragment ?"}
    C -- "å¦" --> D["è®¡å…¥ï¼šå¯é¢†å–"]
    C -- "æ˜¯" --> E["å¿½ç•¥"]
    B -- "å¦" --> F{"fragmentStatus ?"}
    F -- "å¦" --> G["è®¡å…¥ï¼šæœªåˆ°æœŸ"]
    F -- "æ˜¯" --> E
```

---

# ç¬¬ä¸ƒéƒ¨åˆ†ï¼šé¢†å–ä¸ç¢ç‰‡å…‘æ¢ï¼ˆä¸‰ç§æ¨¡å¼ï¼‰

---

## å…«ã€æ“ä½œæ¨¡å¼å®šä¹‰

| mode          | å«ä¹‰         |
| ------------- | ---------- |
| CLAIM         | ä¸€é”®é¢†å–ï¼ˆéœ€æŒ‡å®šä»“ä½ï¼Œç®¡ç†å‘˜ä»£ç”¨æˆ·æ‰§è¡Œï¼‰ |
| FRAG_LOCKED   | å…‘æ¢æœªè§£é”ç¢ç‰‡    |
| FRAG_UNLOCKED | å…‘æ¢å·²è§£é”æœªé¢†å–ç¢ç‰‡ |

---

> æ³¨ï¼šCLAIM / FRAG_LOCKED / FRAG_UNLOCKED å‡éœ€æŒ‡å®šä»“ä½ï¼ˆL1 / L2 / L3ï¼‰ã€‚
> å…¶ä¸­ CLAIM / FRAG_* ç”±ç®¡ç†å‘˜ä»£ç”¨æˆ·æ‰§è¡Œï¼Œéœ€ç”¨æˆ·æˆæƒã€‚

### ä»“ä½å‚æ•°çº¦å®šï¼ˆé€šç”¨ï¼‰

* `lockType = 1` â†’ L1
* `lockType = 2` â†’ L2
* `lockType = 3` â†’ L3

## ä¹ã€ç»Ÿä¸€æ‰«æå†³ç­–æµç¨‹ï¼ˆç»ˆæé—­ç¯ï¼‰


```mermaid
flowchart TD
    A["å¼€å§‹æ‰«æ\né€‰æ‹©ä»“ Lx\né€‰æ‹©æ¨¡å¼ mode\nä»åˆçº¦å­˜å‚¨æ¸¸æ ‡å¼€å§‹\næ¯æ¬¡æœ€å¤šå¤„ç† 50 æ¡"] 
      --> B["è¯»å–è®°å½• r = Lx[i]\nå­—æ®µï¼štime / amount / claimStatus / fragmentStatus"] 
      --> C{"æ˜¯å¦æœªåˆ°æœŸï¼Ÿ\n r.time > now"}

    %% ================= æœªåˆ°æœŸ =================
    C -- "æ˜¯ï¼ˆæœªåˆ°æœŸï¼‰" --> C1{"å½“å‰ mode æ˜¯ä»€ä¹ˆï¼Ÿ"}

    %% --- CLAIM ---
    C1 -- "mode = CLAIM" --> X1["break\né¢†å–æ¨¡å¼ï¼šåªèƒ½é¢†å·²åˆ°æœŸ\næœªåˆ°æœŸç›´æ¥åœæ­¢"]

    %% --- FRAG_UNLOCKED ---
    C1 -- "mode = FRAG_UNLOCKED" --> X2["break\nå·²è§£é”ç¢ç‰‡æ¨¡å¼ï¼š\né‡åˆ°æœªåˆ°æœŸç›´æ¥åœæ­¢"]

    %% --- FRAG_LOCKED ---
    C1 -- "mode = FRAG_LOCKED" --> D1{"æ˜¯å¦å·²å…‘æ¢ç¢ç‰‡ï¼Ÿ\nfragmentStatus == true"}

    D1 -- "æ˜¯ï¼ˆå·²å…‘æ¢ï¼‰" --> Y1["continue\nè·³è¿‡å·²å…‘æ¢è®°å½•\nç»§ç»­æ‰¾åç»­å¯å…‘æ¢çš„æœªè§£é”è®°å½•"]
    D1 -- "å¦ï¼ˆæœªå…‘æ¢ï¼‰" --> D2{"æ˜¯å¦å·²é¢†å–ï¼Ÿ\nclaimStatus == true"}

    D2 -- "æ˜¯ï¼ˆå·²é¢†å–ï¼‰" --> X3["break\nå·²é¢†å–æ˜¯ä¸å¯è·¨è¶Šæ–­ç‚¹"]
    D2 -- "å¦ï¼ˆæœªé¢†å–ï¼‰" --> P1["æ‰§è¡Œå…‘æ¢ç¢ç‰‡\nfragmentStatus = true\nsum += amount\ni++"]

    P1 --> T1{"sum >= targetAmount ?"}
    T1 -- "æ˜¯" --> X6["break\nè¾¾åˆ°ç›®æ ‡å…‘æ¢æ•°é‡"]
    T1 -- "å¦" --> A

    %% ================= å·²åˆ°æœŸ =================
    C -- "å¦ï¼ˆå·²åˆ°æœŸï¼‰" --> E{"æ˜¯å¦å·²é¢†å–ï¼Ÿ\nclaimStatus == true"}

    %% --- å·²é¢†å– ---
    E -- "æ˜¯ï¼ˆå·²é¢†å–ï¼‰" --> E1{"å½“å‰ mode æ˜¯ä»€ä¹ˆï¼Ÿ"}

    E1 -- "mode = CLAIM" --> Y2["continue\nå·²é¢†å–ä¸å¯å†é¢†\nè·³è¿‡ç»§ç»­æ‰«æ"]
    E1 -- "mode = FRAG_LOCKED" --> X4["break\næœªè§£é”ç¢ç‰‡æ¨¡å¼ï¼š\né‡å·²é¢†å–è§†ä¸ºæ–­ç‚¹"]
    E1 -- "mode = FRAG_UNLOCKED" --> X5["break\nå·²è§£é”ç¢ç‰‡æ¨¡å¼ï¼š\né‡å·²é¢†å–è§†ä¸ºæ–­ç‚¹"]

    %% --- æœªé¢†å– ---
    E -- "å¦ï¼ˆæœªé¢†å–ï¼‰" --> F{"æ˜¯å¦å·²å…‘æ¢ç¢ç‰‡ï¼Ÿ\nfragmentStatus == true"}

    %% --- å·²å…‘æ¢ ---
    F -- "æ˜¯ï¼ˆå·²å…‘æ¢ï¼‰" --> F1{"å½“å‰ mode æ˜¯ä»€ä¹ˆï¼Ÿ"}

    F1 -- "mode = CLAIM" --> Y3["continue\nå·²å…‘æ¢ä¸å¯é¢†å–\nè·³è¿‡ç»§ç»­æ‰«æ"]
    F1 -- "mode = FRAG_LOCKED" --> Y4["continue\næœªè§£é”ç¢ç‰‡æ¨¡å¼ï¼š\nå·²è§£é”è®°å½•ç›´æ¥è·³è¿‡"]
    F1 -- "mode = FRAG_UNLOCKED" --> X5

    %% --- å¯å¤„ç†è®°å½• ---
    F -- "å¦ï¼ˆæœªå…‘æ¢ï¼‰" --> G{"æ ¹æ® mode æ‰§è¡ŒåŠ¨ä½œ"}

    %% CLAIM åŠ¨ä½œ
    G -- "mode = CLAIM" --> P2["æ‰§è¡Œé¢†å–\nclaimStatus = true\nsum += amount\ni++"]
    P2 --> A

    %% FRAG_LOCKEDï¼šå·²åˆ°æœŸè®°å½•
    G -- "mode = FRAG_LOCKED" --> Y5["continue\næœªè§£é”ç¢ç‰‡æ¨¡å¼ï¼š\nå·²åˆ°æœŸè®°å½•ä¸å‚ä¸å…‘æ¢\ni++"]
    Y5 --> A

    %% FRAG_UNLOCKEDï¼šå·²è§£é”æœªé¢†å–
    G -- "mode = FRAG_UNLOCKED" --> P3["æ‰§è¡Œå…‘æ¢ç¢ç‰‡\nfragmentStatus = true\nsum += amount\ni++"]
    P3 --> T2{"sum >= targetAmount ?"}
    T2 -- "æ˜¯" --> X6
    T2 -- "å¦" --> A
```

---

## ä¹ç‚¹ä¸€ã€ä¸€é”®é¢†å–é”€æ¯è§„åˆ™ï¼ˆä»… CLAIM æ¨¡å¼ç”Ÿæ•ˆï¼‰

> ä»…ä½œç”¨äº **CLAIMï¼ˆä¸€é”®é¢†å–ï¼‰**ï¼Œå¯¹ **FRAG_LOCKED / FRAG_UNLOCKED** æ— å½±å“ã€‚
> é¢†å–å®Œæˆåï¼Œå¿…é¡»å°†å¯¹åº”é”ä»“è®°å½•çš„ `claimStatus` æ ‡è®°ä¸ºå·²é¢†å–ï¼Œé˜²æ­¢åç»­é‡å¤é¢†å–æˆ–å…‘æ¢ã€‚

### è§„åˆ™è¯´æ˜ï¼ˆæŒ‰é€‰æ‹©ä»“ç»Ÿè®¡ï¼‰

* å…ˆ**é€‰æ‹©ä»“ç±»å‹ï¼ˆL1 / L2 / L3ï¼‰**ï¼Œåªåœ¨**è¯¥ä»“**å†…ç»Ÿè®¡æœ¬æ¬¡å¯é¢†å–æ€»é¢
* åªåœ¨é¢†å–æ—¶ `_mint`
* é¢†å–æ—¶ **å…ˆ mintï¼Œå† burn**

### é”€æ¯æ¯”ä¾‹ï¼ˆé’ˆå¯¹â€œå¯é¢†å–é‡‘é¢â€çš„æ¯”ä¾‹ï¼‰

| ä»“ç±»å‹ | é”€æ¯æ¯”ä¾‹ | å®é™…åˆ†å‘æ¯”ä¾‹ |
| ---- | ---- | ------ |
| L1   | 75%  | 25%    |
| L2   | 50%  | 50%    |
| L3   | 0%   | 100%   |

### æ‰§è¡Œæ­¥éª¤ï¼ˆCLAIMï¼‰

1. ç®¡ç†å‘˜ä»£ç”¨æˆ·æ‰§è¡Œï¼Œæ ¡éªŒç”¨æˆ·æˆæƒ
2. é€‰æ‹©ä»“ç±»å‹ `Lx`ï¼ˆL1 / L2 / L3ï¼‰
3. æ ¡éªŒè®¢å•å·ï¼š`orderId` åœ¨ç”¨æˆ·åœ°å€ä¸‹ä¸å¾—é‡å¤
4. ä»…æ‰«æ `Lx` å†…æ‰€æœ‰**å·²åˆ°æœŸä¸”æœªé¢†å–/æœªå…‘æ¢**çš„è®°å½•
5. ç´¯è®¡ `claimableLx`
6. å…ˆ `_mint` å…¨é‡ `claimableLx` åˆ°åˆçº¦è‡ªèº«
7. æŒ‰ä»“ç±»å‹æ‰§è¡Œ `burn`ï¼ˆåªå¯¹å½“å‰ `Lx` ç”Ÿæ•ˆï¼‰ï¼š
    * è‹¥ `Lx = L1`ï¼Œ`burnLx = claimableLx * 75%`
    * è‹¥ `Lx = L2`ï¼Œ`burnLx = claimableLx * 50%`
    * è‹¥ `Lx = L3`ï¼Œ`burnLx = 0`
8. å®é™…åˆ°è´¦ï¼š
    * `netLx = claimableLx - burnLx`
9. å°† `netLx` è½¬è´¦ç»™ç”¨æˆ·
10. å°†æœ¬æ¬¡é¢†å–åˆ°çš„ `Lx` è®°å½•é€æ¡ `claimStatus = true`
11. å†™å…¥è®¢å•è®°å½•ï¼ˆå« `amount/burnAmount/netAmount/timestamp/status`ï¼‰
12. è§¦å‘äº‹ä»¶ï¼ˆç¤ºä¾‹ï¼‰ï¼š

```solidity
emit ClaimWithBurn(user, claimableLx, burnLx, netLx, Lx);
```

> æ³¨ï¼šäº‹ä»¶å­—æ®µå¯æŒ‰å®ç°è°ƒæ•´ï¼Œä½†å¿…é¡»èƒ½å®¡è®¡æœ¬æ¬¡ L1/L2 çš„é”€æ¯é‡ä¸å‡€é¢†å–é‡ã€‚

# ä¹ç‚¹äºŒã€é¢†å–é¢„è§ˆï¼ˆä»… CLAIMï¼‰

```solidity
previewClaimable(address user, uint8 lockType) returns (uint256 claimable, uint256 burnAmount, uint256 netAmount, uint256 processed, uint256 nextCursor)
```

### è§„åˆ™

* ä»…ç”¨äº CLAIM é¢†å–é¢„è§ˆï¼Œä¸ç”¨äºå…‘æ¢
* ä»…æ‰«æ**åˆçº¦å½“å‰æ¸¸æ ‡ä½ç½®ä¹‹åæœ€å¤š 50 æ¡**
    * æ¸¸æ ‡é”®ï¼š`user + lockType + CLAIM`
* è¿”å›æœ¬æ¬¡â€œå®é™…å¯é¢†å–çš„æœ€å¤§æ•°é‡â€ï¼ˆä¸ `claimAll` åŒå£å¾„ï¼‰

## ä¹ç‚¹ä¸‰ã€å…³é”®å®ç°çº¦å®šï¼ˆå·²ç¡®è®¤ï¼‰

### å·²ç¡®è®¤

1. `startMining` ä»…å…è®¸è°ƒç”¨ä¸€æ¬¡ï¼›é‡å¤è°ƒç”¨**å¿½ç•¥**ï¼ˆä¸æ”¹å˜ä»»ä½•çŠ¶æ€ï¼‰ã€‚
2. `exchangeLockedFragment / exchangeUnlockedFragment`ï¼šå…ˆè®¡ç®—å¯å…‘æ¢æ•°é‡ï¼Œè‹¥ `< targetAmount` åˆ™**ä¸æ‰§è¡Œä»»ä½•çŠ¶æ€å˜æ›´å¹¶è¿”å›é”™è¯¯**ã€‚
3. æ—¶é—´å¸¸é‡å›ºå®šï¼š`month = 30 days`ï¼Œ`year = 365 days`ã€‚
4. å…‘æ¢ç¢ç‰‡æ—¶æ‰§è¡Œé¡ºåºï¼š**å…ˆ `_mint` å† `_burn`**ï¼ˆç¢ç‰‡ä¸éœ€è¦ç‹¬ç«‹è½½ä½“ï¼Œ`_mint/_burn` å‡ä¸ºæœ¬å¸ï¼›**ä¸è½¬è´¦ç»™ç”¨æˆ·**ï¼Œæ‰§è¡Œå®Œæˆè¿”å›æœ¬æ¬¡æ‰§è¡Œæ•°é‡ï¼Œåç«¯è‡ªè¡Œè®°è´¦ï¼‰ã€‚
5. `getLockStats` è¿”å›ç»“æ„ä½“/å…ƒç»„ï¼ˆä¸è¿”å› JSON å­—ç¬¦ä¸²ï¼‰ã€‚
6. ç¬¬ä¸€å¹´åˆå§‹åŒ–å»ºè®®æ–¹æ¡ˆç¡®å®šä¸ºï¼š
    * `startMining` è®¾ç½® `yearBudget = remainingCap / 2`ã€`yearMinted = 0`ã€`yearStartTs = miningStart`ã€`lastSettledYear = 0`
    * `settleToCurrentYear` åªç»“ç®—**å·²ç»“æŸçš„å¹´åº¦**ï¼š
      `while (lastSettledYear + 1 < currentYear) { ... }`
7. æ‰«æç±»æ¥å£ä½¿ç”¨**åˆçº¦å­˜å‚¨æ¸¸æ ‡**ï¼Œæ¯æ¬¡æœ€å¤šéå† **50 æ¡**ï¼ˆåˆçº¦å†…å›ºå®šä¸Šé™ï¼Œä¸ä½œä¸ºå…¥å‚ï¼‰ï¼Œä¸”**ä¸æä¾›é‡ç½®æ¸¸æ ‡**åŠŸèƒ½ã€‚
    * æ¸¸æ ‡é”®ï¼š`user + lockType + mode` ç‹¬ç«‹å­˜å‚¨ã€‚
    * é‡åˆ°â€œæœªåˆ°æœŸ breakâ€æ—¶ï¼Œæ¸¸æ ‡åœç•™åœ¨**æœªåˆ°æœŸè®°å½•çš„ä½ç½®**ï¼ˆå‰åºå·²å¤„ç†å®Œï¼‰ã€‚
8. L1/L2 é¢†å–ä¸å…‘æ¢ç¢ç‰‡æ—¶çš„æ‰§è¡Œæ–¹å¼ï¼š
    * é¢†å–ï¼ˆCLAIMï¼‰ï¼šåˆçº¦å…ˆ `_mint` åˆ°è‡ªèº« â†’ `burn` é”€æ¯æ¯”ä¾‹éƒ¨åˆ† â†’ `transfer` å‡€é¢ç»™ç”¨æˆ·
    * å…‘æ¢ç¢ç‰‡ï¼šåˆçº¦å…ˆ `_mint` åˆ°è‡ªèº« â†’ **å…¨é‡** `burn`ï¼ˆä¸è½¬è´¦ï¼‰
9. æ–°å¢ `previewClaimable(user, lockType)`ï¼šåªæŸ¥çœ‹**å½“å‰åˆçº¦æ¸¸æ ‡ä¹‹åæœ€å¤š 50 æ¡**è®°å½•ï¼Œè¿”å›â€œæœ¬æ¬¡å¯å®é™…é¢†å–çš„æœ€å¤§æ•°é‡â€ï¼ˆä¸æ”¯æŒå…‘æ¢é¢„è§ˆï¼‰ã€‚
10. `getLockStats` å…è®¸**ä¸€æ¬¡æ€§å…¨é‡éå†**è¯¥ä»“å…¨éƒ¨è®°å½•ï¼Œå»ºè®®ä»…ç”¨äº `view` è°ƒç”¨ï¼ˆé“¾ä¸Šè°ƒç”¨å¯èƒ½è¶…å‡º gasï¼‰ã€‚
    * è‹¥æ•°æ®é‡å¾ˆå¤§ï¼Œä½¿ç”¨ `getLockStatsPaged` åˆ†é¡µç»Ÿè®¡ã€‚
11. æƒé™æ§åˆ¶ï¼š`startMining`ã€`allocateEmissionToLocks`ã€çŸ¿æœºåˆ†å‘ç›¸å…³å…¥å£éœ€**ç®¡ç†å‘˜**æƒé™ã€‚
    * `exchangeLockedFragment / exchangeUnlockedFragment` ä¹Ÿéœ€**ç®¡ç†å‘˜**è°ƒç”¨ï¼Œå¹¶è¦æ±‚**ç”¨æˆ·æˆæƒ**ï¼ˆé“¾ä¸Šæˆæƒè¡¨ï¼‰ã€‚
    * æˆæƒæ–¹å¼ï¼šç”¨æˆ·è°ƒç”¨ `approveOperator(operator, approved)`ï¼Œåˆçº¦æ ¡éªŒ `operator` æ˜¯å¦è¢«æˆæƒã€‚
    * åˆçº¦éƒ¨ç½²è€…æ‹¥æœ‰æ‰€æœ‰æƒé™ï¼ˆ**å”¯ä¸€å¯è°ƒç”¨ `setAdmin`**ï¼‰ï¼Œç®¡ç†å‘˜ä¸å…·å¤‡è®¾ç½®ç®¡ç†å‘˜æƒé™ã€‚
    * `claimAll` éœ€**ç®¡ç†å‘˜**è°ƒç”¨ï¼Œå¹¶è¦æ±‚**ç”¨æˆ·æˆæƒ**ã€‚
12. è¿”å›å€¼å£å¾„ï¼š
* `claimAll` è¿”å›**å‡€åˆ°è´¦æ•°é‡**
* `exchangeLockedFragment / exchangeUnlockedFragment` è¿”å›**æœ¬æ¬¡æ‰§è¡Œæ•°é‡**
13. è®¢å•å·ï¼š
* `orderId` ç±»å‹ä¸º `uint256`
* **æŒ‰ç”¨æˆ·å”¯ä¸€**ï¼Œé‡å¤ç›´æ¥æŠ¥é”™
* `allocateEmissionToLocks` ä»¥ `to` ä½œä¸ºè®¢å•å½’å±ç”¨æˆ·
* `claimAll` ä»¥ `user` ä½œä¸ºè®¢å•å½’å±ç”¨æˆ·
* `exchange*` ä»¥ `user` ä½œä¸ºè®¢å•å½’å±ç”¨æˆ·
* è®¢å•æŸ¥è¯¢éœ€ `user + orderId`
14. æ‰«æä¸Šé™å¯é…ç½®ï¼š
* ç®¡ç†å‘˜å¯è®¾ç½® `maxScanLimit`
* `estimateMaxCount(perRecordGas, fixedGas)` è¿”å›ç†è®ºå»ºè®®å€¼

## ä¹ç‚¹å››ã€æ‰§è¡Œç»†èŠ‚è¡¥å……

1. åˆå§‹åˆ†é… 10% åœ¨éƒ¨ç½²/åˆå§‹åŒ–æ—¶ `_mint`ï¼Œä½œä¸ºâ€œä»…é¢†å–æ—¶ mintâ€çš„**å”¯ä¸€ä¾‹å¤–**ã€‚
2. å…‘æ¢ç¢ç‰‡ä¸è½¬è´¦æœ¬å¸ï¼Œæ‰§è¡Œæµç¨‹ä¸ºâ€œåˆçº¦ `_mint` â†’ å…¨é‡ `_burn` â†’ è¿”å›æ‰§è¡Œæ•°é‡â€ã€‚
3. `previewClaimable` è¿”å›å­—æ®µç¡®è®¤ï¼š`claimable / burnAmount / netAmount / processed / nextCursor`ã€‚
4. è®¢å•è®°å½•å†™å…¥ï¼š
    * ä»…åœ¨æ‰§è¡ŒæˆåŠŸåå†™å…¥è®¢å•è®°å½•ï¼›è‹¥è®¢å•å·é‡å¤åˆ™ç›´æ¥æŠ¥é”™ï¼Œä¸å†™å…¥ã€‚
    * `status` å†™å…¥ä¸º `0=æˆåŠŸ`ï¼ˆå¤±è´¥åœºæ™¯æ— è®°å½•ï¼‰ã€‚
    * `amount` å£å¾„ï¼š`allocate=amount`ï¼Œ`exchange=targetAmount`ï¼Œ`claim=0`ã€‚
    * `executedAmount` å£å¾„ï¼š`allocate=amount`ï¼Œ`claim=claimableLx`ï¼Œ`exchange=æœ¬æ¬¡æ‰§è¡Œæ•°é‡`ã€‚
    * `distType=2ï¼ˆç›´æ¥åˆ†å‘ï¼‰` æ—¶ï¼š
        * `methodType=ALLOCATE`ï¼ˆä¸æ–°å¢ç±»å‹ï¼‰
        * `amount=amount`
        * `executedAmount=amount`
        * `netAmount=amount`
        * `burnAmount=0`
    * `netAmount` ä»… `claim` ä¸ `distType=2` æœ‰æ„ä¹‰ï¼Œå…¶å®ƒæ–¹æ³•ä¸º `0`ã€‚
5. `exchangeLockedFragment / exchangeUnlockedFragment` ä¸º**ç®¡ç†å‘˜è°ƒç”¨**ï¼Œéœ€æ ¡éªŒ**ç”¨æˆ·æˆæƒ**ï¼ˆé“¾ä¸Šæˆæƒè¡¨ï¼‰ã€‚
6. æˆæƒæœºåˆ¶ï¼ˆé“¾ä¸Šæˆæƒè¡¨ï¼‰å»ºè®®ï¼š
    * `mapping(user => mapping(operator => bool))`
    * ç”¨æˆ·è°ƒç”¨ `approveOperator(operator, approved)` è®¾ç½®æˆæƒ
    * ç®¡ç†å‘˜è°ƒç”¨ `exchange*` æ—¶æ ¡éªŒ `approved == true`


# ç¬¬å…«éƒ¨åˆ†ï¼šå­—æ®µ & æ–¹æ³•å®Œæ•´å¯¹ç…§è¡¨

---

## åã€æ ¸å¿ƒå­—æ®µè¡¨

| å­—æ®µ                | å«ä¹‰     |
| ----------------- | ------ |
| CAP               | æ€»å‘è¡Œä¸Šé™  |
| remainingCap      | å‰©ä½™å¯æŒ–é¢åº¦ |
| miningStart       | æŒ–çŸ¿èµ·å§‹æ—¶é—´ |
| yearBudget        | å½“å¹´æœ€å¤§å‘è¡Œ |
| yearMinted        | å½“å¹´å·²åˆ†å‘  |
| LockRecord.time   | è§£é”æ—¶é—´   |
| LockRecord.amount | é”ä»“é¢åº¦   |
| claimStatus       | æ˜¯å¦å·²é¢†å–  |
| fragmentStatus    | æ˜¯å¦å·²å…‘æ¢  |

---

## åä¸€ã€æ–¹æ³•è¯´æ˜è¡¨

| æ–¹æ³•å                      | å«ä¹‰      | å…¥å‚         | è¿”å›      |
| ------------------------ | ------- | ---------- | ------- |
| startMining              | å¯åŠ¨æŒ–çŸ¿    | æ—           | æ—        |
| settleToCurrentYear      | å¹´åº¦ç»“ç®—    | æ—           | æ—        |
| getTodayMintable         | ä»Šæ—¥æœ€å¤§å‘è¡Œé‡ | æ—           | uint256 |
| allocateEmissionToLocks  | åˆ†å‘é¢åº¦ï¼ˆå…¥ä»“/ç›´æ¥ï¼‰ | to, amount, lockType, distType, orderId | æ—        |
| claimAll                 | ç®¡ç†å‘˜ä»£ç”¨æˆ·é¢†å–ï¼ˆæŒ‡å®šä»“ä½ï¼Œå« L1/L2 é”€æ¯è§„åˆ™ï¼‰ | user, lockType, orderId | uint256 |
| exchangeLockedFragment   | ç®¡ç†å‘˜ä»£ç”¨æˆ·å…‘æ¢æœªè§£é”ç¢ç‰‡ï¼ˆæŒ‡å®šä»“ä½ï¼‰ | user, lockType, target, orderId | uint256 |
| exchangeUnlockedFragment | ç®¡ç†å‘˜ä»£ç”¨æˆ·å…‘æ¢å·²è§£é”ç¢ç‰‡ï¼ˆæŒ‡å®šä»“ä½ï¼‰ | user, lockType, target, orderId | uint256 |
| getLockStats             | æŸ¥è¯¢é”ä»“ç»Ÿè®¡ï¼ˆæŒ‡å®šä»“ä½ï¼‰ | user, lockType | å¤šå­—æ®µ     |
| getLockStatsPaged        | æŸ¥è¯¢é”ä»“ç»Ÿè®¡ï¼ˆåˆ†é¡µï¼‰ | user, lockType, cursor | å¤šå­—æ®µ     |
| previewClaimable         | é¢†å–é¢„è§ˆï¼ˆä»… CLAIMï¼‰ | user, lockType | å¤šå­—æ®µ     |
| getOrder                 | è®¢å•æŸ¥è¯¢ï¼ˆæŒ‰è®¢å•å·ï¼‰ | user, orderId | å¤šå­—æ®µ     |
| approveOperator          | æˆæƒç®¡ç†å‘˜æ“ä½œ | operator, approved | æ—  |
| setAdmin                 | è®¾ç½®ç®¡ç†å‘˜ï¼ˆä»…éƒ¨ç½²è€…ï¼‰ | newAdmin | æ—  |
| setMaxScanLimit          | è®¾ç½®æ‰«æä¸Šé™ | limit | æ—  |
| getMaxScanLimit          | æŸ¥è¯¢æ‰«æä¸Šé™ | æ—  | uint256 |
| estimateMaxCount         | é¢„ä¼°å»ºè®®ä¸Šé™ | perRecordGas, fixedGas | uint256 |

---

## åäºŒã€getLockStats è¿”å›å­—æ®µï¼ˆç»“æ„ä½“/å…ƒç»„ï¼‰

| å­—æ®µå | å«ä¹‰ |
| --- | --- |
| totalCount | è¯¥ä»“æ€»è®°å½•æ•° |
| totalAmount | è¯¥ä»“æ€»é¢åº¦ |
| claimableCount | å¯é¢†å–è®°å½•æ•°ï¼ˆå·²åˆ°æœŸä¸”æœªé¢†å–æœªå…‘æ¢ï¼‰ |
| claimableAmount | å¯é¢†å–é¢åº¦ |
| unmaturedCount | æœªåˆ°æœŸè®°å½•æ•° |
| unmaturedAmount | æœªåˆ°æœŸé¢åº¦ |
| claimedCount | å·²é¢†å–è®°å½•æ•° |
| claimedAmount | å·²é¢†å–é¢åº¦ |
| fragmentedCount | å·²å…‘æ¢ç¢ç‰‡è®°å½•æ•° |
| fragmentedAmount | å·²å…‘æ¢ç¢ç‰‡é¢åº¦ |
| earliestUnlockTime | æœ€è¿‘ä¸€æ¬¡å¯è§£é”æ—¶é—´ï¼ˆç”¨äºå‰ç«¯å€’è®¡æ—¶ï¼‰ |
| latestUnlockTime | æœ€æ™šè§£é”æ—¶é—´ |
| lastIndex | æœ€åä¸€æ¡è®°å½•ç´¢å¼•ï¼ˆä¾¿äºåˆ†é¡µï¼‰ |

---

## åä¸‰ã€æ¥å£ç­¾åï¼ˆå¤–éƒ¨å¯è§ï¼‰

```solidity
// ä»…ç®¡ç†å‘˜
function startMining() external;

// å¹´åº¦ç»“ç®—ï¼ˆå¯¹å¤–å¯è°ƒç”¨ï¼Œå†…éƒ¨æ“ä½œå‰ä¹Ÿä¼šè°ƒç”¨ï¼‰
function settleToCurrentYear() public;

// ä»Šæ—¥æœ€å¤§å‘è¡Œé‡ï¼ˆåªè¯»ï¼‰
function getTodayMintable() external view returns (uint256);

// ä»…ç®¡ç†å‘˜ï¼šåˆ†å‘é¢åº¦ï¼ˆå…¥ä»“/ç›´æ¥ï¼‰
function allocateEmissionToLocks(address to, uint256 amount, uint8 lockType, uint8 distType, uint256 orderId) external;

// ä»…ç®¡ç†å‘˜ï¼šä»£ç”¨æˆ·ä¸€é”®é¢†å–ï¼ˆæŒ‡å®šä»“ä½ï¼Œè¿”å›å‡€åˆ°è´¦æ•°é‡ï¼‰
// æ³¨æ„ï¼šéœ€è¦ç”¨æˆ·æˆæƒ
function claimAll(address user, uint8 lockType, uint256 orderId) external returns (uint256);

// ä»…ç®¡ç†å‘˜ï¼šå…‘æ¢æœªè§£é”ç¢ç‰‡ï¼ˆè¿”å›æœ¬æ¬¡æ‰§è¡Œæ•°é‡ï¼‰
// æ³¨æ„ï¼šéœ€è¦ç”¨æˆ·æˆæƒ
function exchangeLockedFragment(address user, uint8 lockType, uint256 targetAmount, uint256 orderId) external returns (uint256);

// ä»…ç®¡ç†å‘˜ï¼šå…‘æ¢å·²è§£é”ç¢ç‰‡ï¼ˆè¿”å›æœ¬æ¬¡æ‰§è¡Œæ•°é‡ï¼‰
// æ³¨æ„ï¼šéœ€è¦ç”¨æˆ·æˆæƒ
function exchangeUnlockedFragment(address user, uint8 lockType, uint256 targetAmount, uint256 orderId) external returns (uint256);

// é”ä»“ç»Ÿè®¡ï¼ˆå…¨é‡éå†ï¼Œä»…å»ºè®® view è°ƒç”¨ï¼‰
function getLockStats(address user, uint8 lockType) external view returns (LockStats memory);

// é”ä»“ç»Ÿè®¡ï¼ˆåˆ†é¡µéå†ï¼‰
function getLockStatsPaged(address user, uint8 lockType, uint256 cursor)
    external
    view
    returns (LockStats memory stats, uint256 nextCursor, uint256 processed, bool finished);

// é¢†å–é¢„è§ˆï¼ˆä»… CLAIMï¼‰
function previewClaimable(address user, uint8 lockType) external view returns (PreviewClaimable memory);

// è®¢å•æŸ¥è¯¢ï¼ˆæŒ‰ç”¨æˆ· + è®¢å•å·ï¼‰
function getOrder(address user, uint256 orderId) external view returns (OrderRecord memory);

// ç”¨æˆ·æˆæƒç®¡ç†å‘˜æ“ä½œ
function approveOperator(address operator, bool approved) external;

// ä»…éƒ¨ç½²è€…ï¼šè®¾ç½®ç®¡ç†å‘˜
function setAdmin(address newAdmin) external;

// ä»…ç®¡ç†å‘˜ï¼šè®¾ç½®æ‰«æä¸Šé™
function setMaxScanLimit(uint256 limit) external;

// æŸ¥è¯¢æ‰«æä¸Šé™
function getMaxScanLimit() external view returns (uint256);

// é¢„ä¼°å»ºè®®ä¸Šé™ï¼ˆç”¨äºå‰ç«¯/åç«¯ä¼°ç®—ï¼‰
function estimateMaxCount(uint256 perRecordGas, uint256 fixedGas) external view returns (uint256);
```

---

## åå››ã€æ„é€ å‡½æ•°ï¼ˆéƒ¨ç½²é˜¶æ®µï¼‰

```solidity
constructor(address admin, address communityAddress) {
    // éƒ¨ç½²æ—¶æ‰§è¡Œåˆå§‹åˆ†é…
    // 4% â†’ åˆçº¦åœ°å€ï¼ˆç”¨äºåç»­é”ä»“/é¢†å–ï¼‰
    // 6% â†’ ç¤¾åŒºåœ°å€ï¼ˆcommunityAddressï¼‰
}
```

### çº¦æŸè¯´æ˜

* `communityAddress` ä¸èƒ½ä¸ºç©ºåœ°å€
* `admin` ä¸èƒ½ä¸ºç©ºåœ°å€
* åˆå§‹åˆ†é…åœ¨éƒ¨ç½²æ—¶ `_mint`ï¼ˆä½œä¸ºâ€œä»…é¢†å–æ—¶ mintâ€çš„å”¯ä¸€ä¾‹å¤–ï¼‰
* åˆçº¦éƒ¨ç½²è€…ä¸ºè¶…çº§ç®¡ç†å‘˜ï¼šæ‹¥æœ‰æ‰€æœ‰æƒé™ä¸”**å”¯ä¸€å¯è°ƒç”¨ `setAdmin`**

---

## åäº”ã€ç»“æ„ä½“å®šä¹‰ï¼ˆè¡¥é½ï¼‰

```solidity
// é”ä»“è®°å½•
struct LockRecord {
    uint256 time;            // è§£é”æ—¶é—´æˆ³
    uint256 amount;          // é¢åº¦
    bool claimStatus;        // æ˜¯å¦å·²é¢†å–
    bool fragmentStatus;     // æ˜¯å¦å·²å…‘æ¢ç¢ç‰‡
}

// é”ä»“ç»Ÿè®¡è¿”å›
struct LockStats {
    uint256 totalCount;
    uint256 totalAmount;
    uint256 claimableCount;
    uint256 claimableAmount;
    uint256 unmaturedCount;
    uint256 unmaturedAmount;
    uint256 claimedCount;
    uint256 claimedAmount;
    uint256 fragmentedCount;
    uint256 fragmentedAmount;
    uint256 earliestUnlockTime;
    uint256 latestUnlockTime;
    uint256 lastIndex;
}

// é¢†å–é¢„è§ˆè¿”å›
struct PreviewClaimable {
    uint256 claimable;   // æœ¬æ¬¡å¯é¢†å–æ€»é¢
    uint256 burnAmount;  // æœ¬æ¬¡åº”é”€æ¯æ•°é‡
    uint256 netAmount;   // æœ¬æ¬¡å®é™…åˆ°è´¦æ•°é‡
    uint256 processed;   // æœ¬æ¬¡å¤„ç†æ¡æ•°
    uint256 nextCursor;  // ä¸‹ä¸€æ¸¸æ ‡ä½ç½®ï¼ˆä»…è®¡ç®—ï¼Œä¸å…¥åº“ï¼‰
}

// è®¢å•ç±»å‹
enum OrderMethodType {
    ALLOCATE,         // åˆ†å‘å…¥ä»“
    CLAIM,            // é¢†å–
    EXCHANGE_LOCKED,  // å…‘æ¢æœªè§£é”ç¢ç‰‡
    EXCHANGE_UNLOCKED // å…‘æ¢å·²è§£é”ç¢ç‰‡
}

// è®¢å•è®°å½•
struct OrderRecord {
    OrderMethodType methodType; // æ–¹æ³•ç±»å‹
    address user;               // è®¢å•å½’å±ç”¨æˆ·
    uint8 lockType;             // ä»“ä½
    uint256 amount;             // æ•°é‡å…¥å‚ï¼ˆallocate=amount / exchange=targetAmount / claim=0ï¼‰
    uint256 executedAmount;     // æœ¬æ¬¡å®é™…æ‰§è¡Œæ•°é‡
    uint256 netAmount;          // å®é™…åˆ°è´¦æ•°é‡ï¼ˆä»…é¢†å–æœ‰æ„ä¹‰ï¼‰
    uint256 burnAmount;         // æœ¬æ¬¡é”€æ¯æ•°é‡
    uint256 timestamp;          // æ‰§è¡Œæ—¶é—´
    uint8 status;               // æ‰§è¡ŒçŠ¶æ€ï¼ˆ0=æˆåŠŸï¼Œ1=å¤±è´¥ï¼‰
}
```

---

## åå…­ã€äº‹ä»¶æ¸…å•

```solidity
// å¹´åº¦ç»“ç®—ï¼šæœªæŒ–å®Œé¢åº¦é”€æ¯
event UnmintedAllocationBurned(uint256 year, uint256 unminted);

// é¢†å–é”€æ¯æ˜ç»†
event ClaimWithBurn(
    address indexed user,
    uint256 claimable,
    uint256 burnAmount,
    uint256 netAmount,
    uint8 lockType
);

// ç›´æ¥åˆ†å‘äº‹ä»¶
event DirectDistributed(
    address indexed to,
    uint256 amount,
    uint256 orderId,
    uint256 timestamp
);
```

> å¦‚éœ€å®¡è®¡å…¥ä»“æˆ–å…‘æ¢ç»†èŠ‚ï¼Œå¯åœ¨å®ç°ä¸­è¡¥å……å¯¹åº”äº‹ä»¶ã€‚

---

## åä¸ƒã€é”™è¯¯è¿”å›ç»“æ„ï¼ˆå»ºè®®ï¼‰

> è¯´æ˜ï¼šSolidity é€šå¸¸ä½¿ç”¨ `revert` æŠ›é”™ï¼Œè¿”å›ç»“æ„å»ºè®®é‡‡ç”¨è‡ªå®šä¹‰é”™è¯¯ç ã€‚

```solidity
error BizError(uint8 code);
```

### é”™è¯¯ç å®šä¹‰ï¼ˆå»ºè®®ï¼‰

| code | é”™è¯¯å | å«ä¹‰ |
| --- | --- | --- |
| 1 | NOT_ADMIN | éç®¡ç†å‘˜è°ƒç”¨ |
| 2 | MINING_NOT_STARTED | æŒ–çŸ¿æœªå¯åŠ¨ |
| 3 | INVALID_LOCK_TYPE | ä»“ä½å‚æ•°éæ³•ï¼ˆé 1/2/3ï¼‰ |
| 4 | ORDER_ID_DUPLICATE | è®¢å•å·é‡å¤ |
| 5 | ANNUAL_BUDGET_EXCEEDED | å¹´åº¦é¢åº¦ä¸è¶³ |
| 6 | EXCHANGE_TARGET_NOT_MET | å¯å…‘æ¢æ•°é‡ä¸è¶³ target |
| 7 | NO_CLAIMABLE | æœ¬æ¬¡æ— å¯é¢†å–æ•°é‡ |
| 8 | ORDER_NOT_FOUND | è®¢å•ä¸å­˜åœ¨ |
| 9 | NOT_AUTHORIZED | æœªè·å¾—ç”¨æˆ·æˆæƒ |
| 10 | INVALID_DIST_TYPE | åˆ†å‘ç±»å‹éæ³•ï¼ˆé 1/2ï¼‰ |
| 11 | INVALID_GAS_PARAM | é¢„ä¼°å‚æ•°éæ³•ï¼ˆå¦‚ 0ï¼‰ |
| 12 | ZERO_AMOUNT | æ•°é‡ä¸º 0 |
| 13 | INVALID_ADDRESS | åœ°å€éæ³•ï¼ˆé›¶åœ°å€ï¼‰ |
| 14 | CAP_EXCEEDED | è¶…å‡ºæ€»é‡ä¸Šé™ |
| 15 | INSUFFICIENT_BALANCE | ä½™é¢ä¸è¶³ |
| 16 | INSUFFICIENT_ALLOWANCE | æˆæƒé¢åº¦ä¸è¶³ |

---

## åå…«ã€æ–¹æ³•æŠ¥é”™æ¸…å•ï¼ˆåŸºäºå·²ç¡®è®¤è§„åˆ™ï¼‰

### startMining
* `NOT_ADMIN`ï¼šéç®¡ç†å‘˜è°ƒç”¨

### setAdmin
* `NOT_ADMIN`ï¼šééƒ¨ç½²è€…è°ƒç”¨
* `INVALID_ADDRESS`ï¼šæ–°ç®¡ç†å‘˜ä¸ºé›¶åœ°å€

### settleToCurrentYear
* `MINING_NOT_STARTED`ï¼šæŒ–çŸ¿æœªå¯åŠ¨

### getTodayMintable
* `MINING_NOT_STARTED`ï¼šæŒ–çŸ¿æœªå¯åŠ¨

### allocateEmissionToLocks
* `NOT_ADMIN`ï¼šéç®¡ç†å‘˜è°ƒç”¨
* `MINING_NOT_STARTED`ï¼šæŒ–çŸ¿æœªå¯åŠ¨
* `INVALID_LOCK_TYPE`ï¼šä»“ä½éæ³•
* `INVALID_DIST_TYPE`ï¼šåˆ†å‘ç±»å‹éæ³•
* `ORDER_ID_DUPLICATE`ï¼šè®¢å•å·é‡å¤
* `ANNUAL_BUDGET_EXCEEDED`ï¼šå¹´åº¦é¢åº¦ä¸è¶³
* `ZERO_AMOUNT`ï¼šæ•°é‡ä¸º 0
* `CAP_EXCEEDED`ï¼šè¶…å‡ºæ€»é‡ä¸Šé™

### claimAll
* `NOT_ADMIN`ï¼šéç®¡ç†å‘˜è°ƒç”¨
* `MINING_NOT_STARTED`ï¼šæŒ–çŸ¿æœªå¯åŠ¨
* `INVALID_LOCK_TYPE`ï¼šä»“ä½éæ³•
* `ORDER_ID_DUPLICATE`ï¼šè®¢å•å·é‡å¤
* `NO_CLAIMABLE`ï¼šæœ¬æ¬¡æ— å¯é¢†å–æ•°é‡
* `NOT_AUTHORIZED`ï¼šæœªè·å¾—ç”¨æˆ·æˆæƒ
* `CAP_EXCEEDED`ï¼šè¶…å‡ºæ€»é‡ä¸Šé™

### exchangeLockedFragment / exchangeUnlockedFragment
* `NOT_ADMIN`ï¼šéç®¡ç†å‘˜è°ƒç”¨
* `MINING_NOT_STARTED`ï¼šæŒ–çŸ¿æœªå¯åŠ¨
* `INVALID_LOCK_TYPE`ï¼šä»“ä½éæ³•
* `ORDER_ID_DUPLICATE`ï¼šè®¢å•å·é‡å¤
* `EXCHANGE_TARGET_NOT_MET`ï¼šå¯å…‘æ¢æ•°é‡ä¸è¶³ target
* `NOT_AUTHORIZED`ï¼šæœªè·å¾—ç”¨æˆ·æˆæƒ
* `CAP_EXCEEDED`ï¼šè¶…å‡ºæ€»é‡ä¸Šé™

### previewClaimable
* `MINING_NOT_STARTED`ï¼šæŒ–çŸ¿æœªå¯åŠ¨
* `INVALID_LOCK_TYPE`ï¼šä»“ä½éæ³•

### getLockStats
* `MINING_NOT_STARTED`ï¼šæŒ–çŸ¿æœªå¯åŠ¨
* `INVALID_LOCK_TYPE`ï¼šä»“ä½éæ³•

### getOrder
* `MINING_NOT_STARTED`ï¼šæŒ–çŸ¿æœªå¯åŠ¨
* `ORDER_NOT_FOUND`ï¼šè®¢å•ä¸å­˜åœ¨

### approveOperator
* å½“å‰æœªå®šä¹‰ä¸šåŠ¡é”™è¯¯ç ï¼ˆå¦‚éœ€æ ¡éªŒå‚æ•°å¯æ–°å¢é”™è¯¯ç ï¼‰

---

#åˆçº¦ä»£ç 
```
## AiRword Aion (AION) (é¡¹ç›®ä»£å¸) åˆçº¦:
åˆçº¦åœ°å€: 0xa008BC1bDDa6dE14F9e834e7A671098C6AA55f40
åˆçº¦ä»£ç :
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title AiRword Aion (AiRWord_v3)
/// @notice ä¾æ® air.md æ–‡æ¡£å®ç°çš„åˆçº¦ï¼ˆä¸­æ–‡æ³¨é‡Šä¸ä¸­æ–‡æ—¥å¿—ï¼‰
contract AiRWord_v3 {
// =========================
// åŸºç¡€å¸¸é‡ä¸å…ƒæ•°æ®
// =========================
string public constant NAME = "AiRword Aion";
string public constant SYMBOL = "AiRword";
uint8 public constant DECIMALS = 18;
uint256 public constant CAP = 210_000_000 * 10 ** uint256(DECIMALS);

    // æ—¶é—´å¸¸é‡
    uint256 private constant MONTH = 1 minutes;
    uint256 private constant YEAR = 365 days;

    // =========================
    // é”™è¯¯ç ï¼ˆBizErrorï¼‰
    // =========================
    error BizError(uint8 code);

    uint8 private constant NOT_ADMIN = 1;
    uint8 private constant MINING_NOT_STARTED = 2;
    uint8 private constant INVALID_LOCK_TYPE = 3;
    uint8 private constant ORDER_ID_DUPLICATE = 4;
    uint8 private constant ANNUAL_BUDGET_EXCEEDED = 5;
    uint8 private constant EXCHANGE_TARGET_NOT_MET = 6;
    uint8 private constant NO_CLAIMABLE = 7;
    uint8 private constant ORDER_NOT_FOUND = 8;
    uint8 private constant NOT_AUTHORIZED = 9;
    uint8 private constant INVALID_DIST_TYPE = 10;
    uint8 private constant INVALID_GAS_PARAM = 11;
    uint8 private constant ZERO_AMOUNT = 12;
    uint8 private constant INVALID_ADDRESS = 13;
    uint8 private constant CAP_EXCEEDED = 14;
    uint8 private constant INSUFFICIENT_BALANCE = 15;
    uint8 private constant INSUFFICIENT_ALLOWANCE = 16;

    // =========================
    // è§’è‰²ä¸æƒé™
    // =========================
    address public immutable owner; // åˆçº¦éƒ¨ç½²è€…ï¼ˆè¶…çº§ç®¡ç†å‘˜ï¼‰
    address public admin; // ç®¡ç†å‘˜ï¼ˆç”±éƒ¨ç½²è€…è®¾ç½®ï¼‰
    address public immutable community; // ç¤¾åŒºåœ°å€

    // =========================
    // ERC20 å­˜å‚¨
    // =========================
    // ä»£å¸æ€»ä¾›åº”é‡ï¼ˆæœ€å°å•ä½ï¼‰
    uint256 private _totalSupply;

    // è´¦æˆ·ä½™é¢æ˜ å°„ï¼šåœ°å€ => ä½™é¢
    mapping(address => uint256) private _balances;

    // æˆæƒé¢åº¦æ˜ å°„ï¼šæˆæƒäºº => è¢«æˆæƒäºº => æˆæƒé¢åº¦
    mapping(address => mapping(address => uint256)) private _allowances;


    // =========================
    // æŒ–çŸ¿ä¸å‘è¡ŒçŠ¶æ€
    // =========================
    uint256 public miningStart;     // æŒ–çŸ¿èµ·å§‹æ—¶é—´
    uint256 public lastSettledYear; // å·²å®Œæˆç»“ç®—çš„æœ€åä¸€å¹´
    uint256 public yearBudget;      // å½“å‰å¹´åº¦æœ€å¤§å‘è¡Œé¢åº¦
    uint256 public yearMinted;      // å½“å‰å¹´åº¦å·²åˆ†å‘é¢åº¦
    uint256 public remainingCap;    // å‰©ä½™å¯æŒ–é¢åº¦ï¼ˆå…¨å±€æ€»é‡ï¼Œä¸æ˜¯å½“å¹´é¢åº¦ï¼‰
    uint256 public yearStartTs;     // å½“å‰å¹´åº¦èµ·å§‹æ—¶é—´

    // =========================
    // æ‰«æä¸Šé™
    // =========================
    uint256 public maxScanLimit = 100;

    // =========================
    // æ•°æ®ç»“æ„
    // =========================
    struct LockRecord {
        uint256 time;           // è§£é”æ—¶é—´æˆ³
        uint256 amount;         // é¢åº¦
        bool claimStatus;       // æ˜¯å¦å·²é¢†å–
        bool fragmentStatus;    // æ˜¯å¦å·²å…‘æ¢ç¢ç‰‡
    }

    struct LockStats {
        uint256 totalCount;         // è¯¥ä»“æ€»è®°å½•æ•°
        uint256 totalAmount;        // è¯¥ä»“æ€»é¢åº¦
        uint256 claimableCount;     // å¯é¢†å–è®°å½•æ•°ï¼ˆå·²åˆ°æœŸä¸”æœªé¢†å–æœªå…‘æ¢ï¼‰
        uint256 claimableAmount;    // å¯é¢†å–é¢åº¦
        uint256 unmaturedCount;     // æœªåˆ°æœŸè®°å½•æ•°
        uint256 unmaturedAmount;    // æœªåˆ°æœŸé¢åº¦
        uint256 claimedCount;       // å·²é¢†å–è®°å½•æ•°
        uint256 claimedAmount;      // å·²é¢†å–é¢åº¦
        uint256 fragmentedCount;    // å·²å…‘æ¢ç¢ç‰‡è®°å½•æ•°
        uint256 fragmentedAmount;   // å·²å…‘æ¢ç¢ç‰‡é¢åº¦
        uint256 earliestUnlockTime; // æœ€è¿‘ä¸€æ¬¡å¯è§£é”æ—¶é—´ï¼ˆç”¨äºå‰ç«¯å€’è®¡æ—¶ï¼‰
        uint256 latestUnlockTime;   // æœ€æ™šè§£é”æ—¶é—´
        uint256 lastIndex;          // æœ€åä¸€æ¡è®°å½•ç´¢å¼•ï¼ˆä¾¿äºåˆ†é¡µï¼‰
    }

    struct PreviewClaimable {
        uint256 claimable;   // æœ¬æ¬¡å¯é¢†å–æ€»é¢
        uint256 burnAmount;  // æœ¬æ¬¡åº”é”€æ¯æ•°é‡
        uint256 netAmount;   // æœ¬æ¬¡å®é™…åˆ°è´¦æ•°é‡
        uint256 processed;   // æœ¬æ¬¡å¤„ç†æ¡æ•°
        uint256 nextCursor;  // ä¸‹ä¸€æ¸¸æ ‡ä½ç½®ï¼ˆä»…è®¡ç®—ï¼Œä¸å…¥åº“ï¼‰
    }

    enum OrderMethodType {
        ALLOCATE,         // åˆ†å‘å…¥ä»“ / ç›´æ¥åˆ†å‘
        CLAIM,            // é¢†å–
        EXCHANGE_LOCKED,  // å…‘æ¢æœªè§£é”ç¢ç‰‡
        EXCHANGE_UNLOCKED // å…‘æ¢å·²è§£é”ç¢ç‰‡
    }

    struct OrderRecord {
        OrderMethodType methodType; // æ–¹æ³•ç±»å‹
        address user;               // è®¢å•å½’å±ç”¨æˆ·
        uint8 lockType;             // ä»“ä½
        uint256 amount;             // æ•°é‡å…¥å‚ï¼ˆallocate=amount / exchange=targetAmount / claim=0ï¼‰
        uint256 executedAmount;     // æœ¬æ¬¡å®é™…æ‰§è¡Œæ•°é‡
        uint256 netAmount;          // å®é™…åˆ°è´¦æ•°é‡ï¼ˆä»…é¢†å–æœ‰æ„ä¹‰ï¼‰
        uint256 burnAmount;         // æœ¬æ¬¡é”€æ¯æ•°é‡
        uint256 timestamp;          // æ‰§è¡Œæ—¶é—´
        uint8 status;               // æ‰§è¡ŒçŠ¶æ€ï¼ˆ0=æˆåŠŸï¼Œ1=å¤±è´¥ï¼‰
    }

    // =========================
    // å­˜å‚¨æ˜ å°„
    // =========================
    // ç”¨æˆ·é”ä»“ï¼šuser => lockType => records
    mapping(address => mapping(uint8 => LockRecord[])) private _locks;

    // æ¸¸æ ‡ï¼šuser => lockType => mode => cursor
    mapping(address => mapping(uint8 => mapping(uint8 => uint256))) private _cursors;

    // è®¢å•è®°å½•ï¼šuser => orderId => record
    mapping(address => mapping(uint256 => OrderRecord)) private _orders;
    mapping(address => mapping(uint256 => bool)) private _orderExists;

    // ç”¨æˆ·æˆæƒï¼šuser => operator => approved
    mapping(address => mapping(address => bool)) private _operatorApproved;

    // æ¨¡å¼å¸¸é‡ï¼ˆç”¨äºæ¸¸æ ‡ï¼‰
    uint8 private constant MODE_CLAIM = 0;
    uint8 private constant MODE_FRAG_LOCKED = 1;
    uint8 private constant MODE_FRAG_UNLOCKED = 2;

    // =========================
    // äº‹ä»¶ï¼ˆæ—¥å¿—è¾“å‡ºï¼‰
    // =========================
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    // å¹´åº¦ç»“ç®—ï¼šæœªæŒ–å®Œé¢åº¦é”€æ¯
    event UnmintedAllocationBurned(uint256 year, uint256 unminted);

    // é¢†å–é”€æ¯æ˜ç»†
    event ClaimWithBurn(
        address indexed user,
        uint256 claimable,
        uint256 burnAmount,
        uint256 netAmount,
        uint8 lockType
    );

    // ç›´æ¥åˆ†å‘äº‹ä»¶
    event DirectDistributed(
        address indexed to,
        uint256 amount,
        uint256 orderId,
        uint256 timestamp
    );

    // =========================
    // æ„é€ å‡½æ•°ï¼ˆéƒ¨ç½²é˜¶æ®µï¼‰
    // =========================
    constructor(address admin_, address communityAddress) {
        if (admin_ == address(0) || communityAddress == address(0)) {
            revert BizError(INVALID_ADDRESS);
        }

        owner = msg.sender;
        admin = admin_;
        community = communityAddress;

        // åˆå§‹åˆ†é…ï¼ˆå”¯ä¸€ä¾‹å¤–å¯ mintï¼‰
        uint256 toContract = (CAP * 4) / 100;
        uint256 toCommunity = (CAP * 6) / 100;
        _mint(address(this), toContract);
        _mint(communityAddress, toCommunity);

        // åˆå§‹åŒ–å‰©ä½™å¯æŒ–é¢åº¦
        remainingCap = CAP - toContract - toCommunity;
    }

    // =========================
    // ERC20 åŸºç¡€æ¥å£
    // =========================
    function name() external pure returns (string memory) {
        return NAME;
    }

    function symbol() external pure returns (string memory) {
        return SYMBOL;
    }

    function decimals() external pure returns (uint8) {
        return DECIMALS;
    }

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner_, address spender) external view returns (uint256) {
        return _allowances[owner_][spender];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        uint256 current = _allowances[from][msg.sender];
        if (current < amount) {
            revert BizError(INSUFFICIENT_ALLOWANCE);
        }
        _approve(from, msg.sender, current - amount);
        _transfer(from, to, amount);
        return true;
    }

    // =========================
    // æƒé™ä¸ç®¡ç†å‘˜
    // =========================
    function setAdmin(address newAdmin) external {
        // ä»…éƒ¨ç½²è€…å¯è®¾ç½®ç®¡ç†å‘˜
        if (msg.sender != owner) {
            revert BizError(NOT_ADMIN);
        }
        if (newAdmin == address(0)) {
            revert BizError(INVALID_ADDRESS);
        }
        admin = newAdmin;
    }

    function approveOperator(address operator, bool approved) external {
        // ç”¨æˆ·æˆæƒç®¡ç†å‘˜æ“ä½œ
        _operatorApproved[msg.sender][operator] = approved;
    }

    // =========================
    // æ‰«æä¸Šé™é…ç½®
    // =========================
    function setMaxScanLimit(uint256 limit) external onlyAdmin {
        maxScanLimit = limit;
    }

    function getMaxScanLimit() external view returns (uint256) {
        return maxScanLimit;
    }

    function estimateMaxCount(uint256 perRecordGas, uint256 fixedGas) external view returns (uint256) {
        // é¢„ä¼°å»ºè®®ä¸Šé™ï¼šæ ¹æ®åŒºå— gasLimit åæ¨å‡ºå¯å®‰å…¨å¤„ç†çš„æœ€å¤§æ¡æ•°
        // perRecordGasï¼šæ¯æ¡è®°å½•é¢„è®¡æ¶ˆè€— gas
        // fixedGasï¼šå›ºå®šå¼€é”€ï¼ˆä¸éšè®°å½•æ•°å˜åŒ–ï¼‰
        if (perRecordGas == 0 || fixedGas == 0) {
            revert BizError(INVALID_GAS_PARAM);
        }
        uint256 gasLimit = block.gaslimit;
        if (gasLimit <= fixedGas) {
            return 0;
        }
        uint256 suggested = (gasLimit - fixedGas) / perRecordGas;
        if (suggested > maxScanLimit) {
            return maxScanLimit;
        }
        return suggested;
    }

    // =========================
    // å¯åŠ¨æŒ–çŸ¿
    // =========================
    function startMining() external onlyAdmin {
        // é‡å¤è°ƒç”¨å¿½ç•¥
        if (miningStart != 0) {
            return;
        }
        miningStart = block.timestamp;
        yearStartTs = miningStart;
        yearBudget = remainingCap / 2;
        yearMinted = 0;
        lastSettledYear = 0;
    }

    // =========================
    // å¹´åº¦ç»“ç®—
    // =========================
    function settleToCurrentYear() public {
        _requireStarted();
        uint256 currentYear = _currentYear();
        while (lastSettledYear + 1 < currentYear) {
            uint256 unminted = yearBudget - yearMinted;
            remainingCap -= unminted;
            emit UnmintedAllocationBurned(lastSettledYear + 1, unminted);
            lastSettledYear += 1;
            yearBudget = remainingCap / 2;
            yearMinted = 0;
            yearStartTs = miningStart + (lastSettledYear * YEAR);
        }
    }

    // =========================
    // ä»Šæ—¥å¯å‘è¡Œé‡ï¼ˆåªè¯»ï¼‰
    // =========================
    function getTodayMintable() external view returns (uint256) {
        _requireStartedView();
        (uint256 budget, uint256 minted, uint256 startTs) = _simulateToCurrentYear();
        uint256 yearRemaining = budget - minted;
        uint256 daysPassed = (block.timestamp - startTs) / 1 days;
        if (daysPassed >= 365) {
            return 0;
        }
        uint256 daysRemaining = 365 - daysPassed;
        return yearRemaining / daysRemaining;
    }

    // =========================
    // åˆ†å‘é¢åº¦ï¼ˆå…¥ä»“/ç›´æ¥ï¼‰
    // =========================
    function allocateEmissionToLocks(
        address to,
        uint256 amount,
        uint8 lockType,
        uint8 distType,
        uint256 orderId
    ) external onlyAdmin {
        _requireStarted();

        if (to == address(0)) {
            revert BizError(INVALID_ADDRESS);
        }
        if (amount == 0) {
            revert BizError(ZERO_AMOUNT);
        }
        if (distType != 1 && distType != 2) {
            revert BizError(INVALID_DIST_TYPE);
        }
        if (distType == 2) {
            if (lockType != 0) {
                revert BizError(INVALID_LOCK_TYPE);
            }
        } else {
            if (!_isValidLockType(lockType)) {
                revert BizError(INVALID_LOCK_TYPE);
            }
        }

        _requireOrderNotExists(to, orderId);

        settleToCurrentYear();

        if (yearMinted + amount > yearBudget) {
            revert BizError(ANNUAL_BUDGET_EXCEEDED);
        }

        yearMinted += amount;
        remainingCap -= amount;

        if (distType == 1) {
            _pushLock(to, lockType, amount);
        } else {
            // ç›´æ¥åˆ†å‘ï¼šç›´æ¥ mint ç»™ç”¨æˆ·
            _mint(to, amount);
            emit DirectDistributed(to, amount, orderId, block.timestamp);
        }

        // å†™å…¥è®¢å•è®°å½•ï¼ˆALLOCATEï¼‰
        OrderRecord storage r = _orders[to][orderId];
        r.methodType = OrderMethodType.ALLOCATE;
        r.user = to;
        r.lockType = lockType;
        r.amount = amount;
        r.executedAmount = amount;
        r.netAmount = (distType == 2) ? amount : 0;
        r.burnAmount = 0;
        r.timestamp = block.timestamp;
        r.status = 0;
        _orderExists[to][orderId] = true;
    }

    // =========================
    // ä¸€é”®é¢†å–ï¼ˆæŒ‡å®šä»“ä½ï¼‰
    // =========================
    function claimAll(address user, uint8 lockType, uint256 orderId) external onlyAdmin returns (uint256) {
        _requireStarted();
        if (!_isValidLockType(lockType)) {
            revert BizError(INVALID_LOCK_TYPE);
        }
        if (!_operatorApproved[user][msg.sender]) {
            revert BizError(NOT_AUTHORIZED);
        }
        _requireOrderNotExists(user, orderId);

        settleToCurrentYear();

        uint256 cursor = _cursors[user][lockType][MODE_CLAIM];
        LockRecord[] storage list = _locks[user][lockType];
        uint256 len = list.length;
        uint256 i = cursor;
        uint256 processed = 0;
        uint256 claimable = 0;

        while (i < len && processed < maxScanLimit) {
            processed++;
            LockRecord storage rec = list[i];
            if (rec.time > block.timestamp) {
                // æœªåˆ°æœŸç›´æ¥åœæ­¢
                break;
            }

            if (rec.claimStatus || rec.fragmentStatus) {
                // å·²é¢†å–æˆ–å·²å…‘æ¢ï¼Œè·³è¿‡
                i++;
                continue;
            }

            // å¯é¢†å–
            rec.claimStatus = true;
            claimable += rec.amount;
            i++;
        }

        // æ›´æ–°æ¸¸æ ‡
        _cursors[user][lockType][MODE_CLAIM] = i;

        if (claimable == 0) {
            revert BizError(NO_CLAIMABLE);
        }

        uint256 burnAmount = _calcBurn(lockType, claimable);
        uint256 netAmount = claimable - burnAmount;

        // é¢†å–ï¼šå…ˆ mint åˆ°è‡ªèº«ï¼Œå† burnï¼Œæœ€åè½¬è´¦å‡€é¢
        _mint(address(this), claimable);
        if (burnAmount > 0) {
            _burn(address(this), burnAmount);
        }
        _transfer(address(this), user, netAmount);

        emit ClaimWithBurn(user, claimable, burnAmount, netAmount, lockType);

        // å†™å…¥è®¢å•è®°å½•ï¼ˆCLAIMï¼‰
        OrderRecord storage r = _orders[user][orderId];
        r.methodType = OrderMethodType.CLAIM;
        r.user = user;
        r.lockType = lockType;
        r.amount = 0;
        r.executedAmount = claimable;
        r.netAmount = netAmount;
        r.burnAmount = burnAmount;
        r.timestamp = block.timestamp;
        r.status = 0;
        _orderExists[user][orderId] = true;

        return netAmount;
    }

    // =========================
    // å…‘æ¢æœªè§£é”ç¢ç‰‡ï¼ˆç®¡ç†å‘˜ä»£ç”¨æˆ·æ‰§è¡Œï¼‰
    // =========================
    function exchangeLockedFragment(
        address user,
        uint8 lockType,
        uint256 targetAmount,
        uint256 orderId
    ) external onlyAdmin returns (uint256) {
        _requireStarted();
        if (!_isValidLockType(lockType)) {
            revert BizError(INVALID_LOCK_TYPE);
        }
        if (!_operatorApproved[user][msg.sender]) {
            revert BizError(NOT_AUTHORIZED);
        }
        _requireOrderNotExists(user, orderId);
        if (targetAmount == 0) {
            revert BizError(EXCHANGE_TARGET_NOT_MET);
        }

        settleToCurrentYear();

        uint256 cursor = _cursors[user][lockType][MODE_FRAG_LOCKED];
        LockRecord[] storage list = _locks[user][lockType];
        uint256 len = list.length;
        uint256 i = cursor;
        uint256 processed = 0;
        uint256 sum = 0;

        while (i < len && processed < maxScanLimit) {
            processed++;
            LockRecord storage rec = list[i];

            if (rec.time > block.timestamp) {
                // æœªåˆ°æœŸ
                if (rec.fragmentStatus) {
                    i++;
                    continue;
                }
                if (rec.claimStatus) {
                    break;
                }

                // å¯å…‘æ¢æœªè§£é”ç¢ç‰‡
                rec.fragmentStatus = true;
                sum += rec.amount;
                i++;
                if (sum >= targetAmount) {
                    break;
                }
                continue;
            }

            // å·²åˆ°æœŸ
            if (rec.claimStatus) {
                break;
            }
            if (rec.fragmentStatus) {
                i++;
                continue;
            }

            // å·²åˆ°æœŸæœªå…‘æ¢ï¼Œæœªè§£é”ç¢ç‰‡ä¸å¤„ç†ï¼Œç»§ç»­æ‰«æ
            i++;
        }

        // æ›´æ–°æ¸¸æ ‡
        _cursors[user][lockType][MODE_FRAG_LOCKED] = i;

        if (sum < targetAmount) {
            revert BizError(EXCHANGE_TARGET_NOT_MET);
        }

        // å…‘æ¢ç¢ç‰‡ï¼šå…ˆ mint åˆ°è‡ªèº«ï¼Œå†å…¨é‡ burnï¼Œä¸è½¬è´¦
        _mint(address(this), sum);
        _burn(address(this), sum);

        // å†™å…¥è®¢å•è®°å½•ï¼ˆEXCHANGE_LOCKEDï¼‰
        OrderRecord storage r = _orders[user][orderId];
        r.methodType = OrderMethodType.EXCHANGE_LOCKED;
        r.user = user;
        r.lockType = lockType;
        r.amount = targetAmount;
        r.executedAmount = sum;
        r.netAmount = 0;
        r.burnAmount = sum;
        r.timestamp = block.timestamp;
        r.status = 0;
        _orderExists[user][orderId] = true;

        return sum;
    }

    // =========================
    // å…‘æ¢å·²è§£é”ç¢ç‰‡ï¼ˆç®¡ç†å‘˜ä»£ç”¨æˆ·æ‰§è¡Œï¼‰
    // =========================
    function exchangeUnlockedFragment(
        address user,
        uint8 lockType,
        uint256 targetAmount,
        uint256 orderId
    ) external onlyAdmin returns (uint256) {
        _requireStarted();
        if (!_isValidLockType(lockType)) {
            revert BizError(INVALID_LOCK_TYPE);
        }
        if (!_operatorApproved[user][msg.sender]) {
            revert BizError(NOT_AUTHORIZED);
        }
        _requireOrderNotExists(user, orderId);
        if (targetAmount == 0) {
            revert BizError(EXCHANGE_TARGET_NOT_MET);
        }

        settleToCurrentYear();

        uint256 cursor = _cursors[user][lockType][MODE_FRAG_UNLOCKED];
        LockRecord[] storage list = _locks[user][lockType];
        uint256 len = list.length;
        uint256 i = cursor;
        uint256 processed = 0;
        uint256 sum = 0;

        while (i < len && processed < maxScanLimit) {
            processed++;
            LockRecord storage rec = list[i];

            if (rec.time > block.timestamp) {
                // æœªåˆ°æœŸç›´æ¥åœæ­¢
                break;
            }

            // å·²åˆ°æœŸ
            if (rec.claimStatus) {
                break;
            }
            if (rec.fragmentStatus) {
                break;
            }

            // å¯å…‘æ¢å·²è§£é”ç¢ç‰‡
            rec.fragmentStatus = true;
            sum += rec.amount;
            i++;
            if (sum >= targetAmount) {
                break;
            }
        }

        // æ›´æ–°æ¸¸æ ‡
        _cursors[user][lockType][MODE_FRAG_UNLOCKED] = i;

        if (sum < targetAmount) {
            revert BizError(EXCHANGE_TARGET_NOT_MET);
        }

        // å…‘æ¢ç¢ç‰‡ï¼šå…ˆ mint åˆ°è‡ªèº«ï¼Œå†å…¨é‡ burnï¼Œä¸è½¬è´¦
        _mint(address(this), sum);
        _burn(address(this), sum);

        // å†™å…¥è®¢å•è®°å½•ï¼ˆEXCHANGE_UNLOCKEDï¼‰
        OrderRecord storage r = _orders[user][orderId];
        r.methodType = OrderMethodType.EXCHANGE_UNLOCKED;
        r.user = user;
        r.lockType = lockType;
        r.amount = targetAmount;
        r.executedAmount = sum;
        r.netAmount = 0;
        r.burnAmount = sum;
        r.timestamp = block.timestamp;
        r.status = 0;
        _orderExists[user][orderId] = true;

        return sum;
    }

    // =========================
    // é¢†å–é¢„è§ˆï¼ˆä»… CLAIMï¼‰
    // =========================
    function previewClaimable(address user, uint8 lockType) external view returns (PreviewClaimable memory) {
        _requireStartedView();
        if (!_isValidLockType(lockType)) {
            revert BizError(INVALID_LOCK_TYPE);
        }

        uint256 cursor = _cursors[user][lockType][MODE_CLAIM];
        LockRecord[] storage list = _locks[user][lockType];
        uint256 len = list.length;
        uint256 i = cursor;
        uint256 processed = 0;
        uint256 claimable = 0;

        while (i < len && processed < maxScanLimit) {
            processed++;
            LockRecord storage rec = list[i];
            if (rec.time > block.timestamp) {
                break;
            }
            if (rec.claimStatus || rec.fragmentStatus) {
                i++;
                continue;
            }
            claimable += rec.amount;
            i++;
        }

        uint256 burnAmount = _calcBurn(lockType, claimable);
        uint256 netAmount = claimable - burnAmount;

        return PreviewClaimable({
            claimable: claimable,
            burnAmount: burnAmount,
            netAmount: netAmount,
            processed: processed,
            nextCursor: i
        });
    }

    // =========================
    // é”ä»“ç»Ÿè®¡ï¼ˆå…¨é‡éå†ï¼‰
    // =========================
    function getLockStats(address user, uint8 lockType) external view returns (LockStats memory) {
        _requireStartedView();
        if (!_isValidLockType(lockType)) {
            revert BizError(INVALID_LOCK_TYPE);
        }

        LockRecord[] storage list = _locks[user][lockType];
        uint256 len = list.length;

        LockStats memory stats;
        stats.totalCount = len;
        stats.lastIndex = (len == 0) ? 0 : (len - 1);

        for (uint256 i = 0; i < len; i++) {
            LockRecord storage rec = list[i];
            stats.totalAmount += rec.amount;

            if (rec.fragmentStatus) {
                // å·²å…‘æ¢ç¢ç‰‡
                stats.fragmentedCount += 1;
                stats.fragmentedAmount += rec.amount;
            } else if (rec.time <= block.timestamp) {
                // å·²åˆ°æœŸ
                if (rec.claimStatus) {
                    stats.claimedCount += 1;
                    stats.claimedAmount += rec.amount;
                } else {
                    stats.claimableCount += 1;
                    stats.claimableAmount += rec.amount;
                }
            } else {
                // æœªåˆ°æœŸä¸”æœªå…‘æ¢
                stats.unmaturedCount += 1;
                stats.unmaturedAmount += rec.amount;
            }

            // æœ€è¿‘/æœ€æ™šè§£é”æ—¶é—´ï¼ˆä»…ç»Ÿè®¡æœªå…‘æ¢ä¸”æœªåˆ°æœŸï¼‰
            if (!rec.fragmentStatus && rec.time > block.timestamp) {
                if (stats.earliestUnlockTime == 0 || rec.time < stats.earliestUnlockTime) {
                    stats.earliestUnlockTime = rec.time;
                }
                if (rec.time > stats.latestUnlockTime) {
                    stats.latestUnlockTime = rec.time;
                }
            }
        }

        return stats;
    }

    // =========================
    // é”ä»“ç»Ÿè®¡ï¼ˆåˆ†é¡µéå†ï¼Œé¿å…è¿‡å¤§æ•°æ®å¯¼è‡´å¤±è´¥ï¼‰
    // =========================
    function getLockStatsPaged(
        address user,
        uint8 lockType,
        uint256 cursor
    )
        external
        view
        returns (LockStats memory stats, uint256 nextCursor, uint256 processed, bool finished)
    {
        _requireStartedView();
        if (!_isValidLockType(lockType)) {
            revert BizError(INVALID_LOCK_TYPE);
        }

        LockRecord[] storage list = _locks[user][lockType];
        uint256 len = list.length;
        uint256 i = cursor;

        while (i < len && processed < maxScanLimit) {
            processed++;
            LockRecord storage rec = list[i];
            stats.totalCount += 1;
            stats.totalAmount += rec.amount;

            if (rec.fragmentStatus) {
                stats.fragmentedCount += 1;
                stats.fragmentedAmount += rec.amount;
            } else if (rec.time <= block.timestamp) {
                if (rec.claimStatus) {
                    stats.claimedCount += 1;
                    stats.claimedAmount += rec.amount;
                } else {
                    stats.claimableCount += 1;
                    stats.claimableAmount += rec.amount;
                }
            } else {
                stats.unmaturedCount += 1;
                stats.unmaturedAmount += rec.amount;
            }

            // æœ€è¿‘/æœ€æ™šè§£é”æ—¶é—´ï¼ˆä»…ç»Ÿè®¡æœªå…‘æ¢ä¸”æœªåˆ°æœŸï¼‰
            if (!rec.fragmentStatus && rec.time > block.timestamp) {
                if (stats.earliestUnlockTime == 0 || rec.time < stats.earliestUnlockTime) {
                    stats.earliestUnlockTime = rec.time;
                }
                if (rec.time > stats.latestUnlockTime) {
                    stats.latestUnlockTime = rec.time;
                }
            }

            i++;
        }

        nextCursor = i;
        finished = (i >= len);
        if (len == 0) {
            stats.lastIndex = 0;
        } else if (finished) {
            stats.lastIndex = len - 1;
        } else {
            stats.lastIndex = i - 1;
        }
    }

    // =========================
    // è®¢å•æŸ¥è¯¢
    // =========================
    function getOrder(address user, uint256 orderId) external view returns (OrderRecord memory) {
        _requireStartedView();
        if (!_orderExists[user][orderId]) {
            revert BizError(ORDER_NOT_FOUND);
        }
        return _orders[user][orderId];
    }

    // =========================
    // å†…éƒ¨å·¥å…·å‡½æ•°
    // =========================
    modifier onlyAdmin() {
        if (!_isAdmin(msg.sender)) {
            revert BizError(NOT_ADMIN);
        }
        _;
    }

    function _isAdmin(address who) private view returns (bool) {
        return (who == admin || who == owner);
    }

    function _requireStarted() private view {
        if (miningStart == 0) {
            revert BizError(MINING_NOT_STARTED);
        }
    }

    function _requireStartedView() private view {
        if (miningStart == 0) {
            revert BizError(MINING_NOT_STARTED);
        }
    }

    function _requireOrderNotExists(address user, uint256 orderId) private view {
        if (_orderExists[user][orderId]) {
            revert BizError(ORDER_ID_DUPLICATE);
        }
    }

    function _isValidLockType(uint8 lockType) private pure returns (bool) {
        return (lockType == 1 || lockType == 2 || lockType == 3);
    }

    function _currentYear() private view returns (uint256) {
        return ((block.timestamp - miningStart) / YEAR) + 1;
    }

    // ä»…ç”¨äº view çš„å¹´åº¦æ¨¡æ‹Ÿç»“ç®—
    function _simulateToCurrentYear()
        private
        view
        returns (uint256 budget, uint256 minted, uint256 startTs)
    {
        uint256 tempRemaining = remainingCap;
        uint256 tempBudget = yearBudget;
        uint256 tempMinted = yearMinted;
        uint256 tempLastSettled = lastSettledYear;
        uint256 tempStartTs = yearStartTs;

        uint256 currentYear = _currentYear();
        while (tempLastSettled + 1 < currentYear) {
            uint256 unminted = tempBudget - tempMinted;
            tempRemaining -= unminted;
            tempLastSettled += 1;
            tempBudget = tempRemaining / 2;
            tempMinted = 0;
            tempStartTs = miningStart + (tempLastSettled * YEAR);
        }

        return (tempBudget, tempMinted, tempStartTs);
    }

    function _pushLock(address to, uint8 lockType, uint256 amount) private {
        uint256 unlockTime;
        if (lockType == 1) {
            unlockTime = block.timestamp + MONTH;
        } else if (lockType == 2) {
            unlockTime = block.timestamp + (2 * MONTH);
        } else {
            unlockTime = block.timestamp + (4 * MONTH);
        }

        _locks[to][lockType].push(
            LockRecord({
                time: unlockTime,
                amount: amount,
                claimStatus: false,
                fragmentStatus: false
            })
        );
    }

    function _calcBurn(uint8 lockType, uint256 claimable) private pure returns (uint256) {
        if (lockType == 1) {
            return (claimable * 75) / 100;
        }
        if (lockType == 2) {
            return (claimable * 50) / 100;
        }
        return 0;
    }

    // =========================
    // ERC20 å†…éƒ¨å®ç°
    // =========================
    function _transfer(address from, address to, uint256 amount) internal {
        if (to == address(0) || from == address(0)) {
            revert BizError(INVALID_ADDRESS);
        }
        uint256 bal = _balances[from];
        if (bal < amount) {
            revert BizError(INSUFFICIENT_BALANCE);
        }
        _balances[from] = bal - amount;
        _balances[to] += amount;
        emit Transfer(from, to, amount);
    }

    function _mint(address to, uint256 amount) internal {
        if (to == address(0)) {
            revert BizError(INVALID_ADDRESS);
        }
        if (_totalSupply + amount > CAP) {
            revert BizError(CAP_EXCEEDED);
        }
        _totalSupply += amount;
        _balances[to] += amount;
        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal {
        if (from == address(0)) {
            revert BizError(INVALID_ADDRESS);
        }
        uint256 bal = _balances[from];
        if (bal < amount) {
            revert BizError(INSUFFICIENT_BALANCE);
        }
        _balances[from] = bal - amount;
        _totalSupply -= amount;
        emit Transfer(from, address(0), amount);
    }

    function _approve(address owner_, address spender, uint256 amount) internal {
        if (owner_ == address(0) || spender == address(0)) {
            revert BizError(INVALID_ADDRESS);
        }
        _allowances[owner_][spender] = amount;
        emit Approval(owner_, spender, amount);
    }
}
```