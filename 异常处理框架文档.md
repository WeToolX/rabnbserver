# 异常处理框架开发文档

## 0. 接入清单（精简版）

1. 业务服务加 `@AbnormalRetryConfig`（配置表名、状态字段、成功/失败值、重试参数等）
2. 业务服务继承 `AbstractAbnormalRetryService`
3. 实现 `checkStatus` 与 `ExceptionHandling`
4. 业务入口必须调用 `checkUserErr`
5. 异常发生时调用 `markAbnormal`
6. 人工处理成功时调用 `ProcessingSuccessful`
7. 必须重写 `manualSuccessRoute()` 并返回路由

## 一、框架定位

### 1. 目标

- 统一异常落库、统一调度、统一重试
- 自动重试失败后可升级人工处理
- 人工处理成功后可回写业务状态，形成闭环
- 业务侵入小（注解 + 继承基类 + 必要方法）

### 2. 边界

- 不关心异常来源
- 不替代业务事务
- 不负责业务幂等（由业务保证）
- 不强制创建业务数据，只修改异常字段与业务状态字段

---

## 二、核心概念

### 1. 异常生命周期（err_status）

| 状态码 | 含义 | 说明 |
| --- | --- | --- |
| 2000 | 正常 | 无异常 |
| 4000 | 异常待自动处理 | 自动重试中 |
| 4001 | 异常需人工处理 | 自动失败或超时 |
| 2001 | 自动处理成功 | 框架回写 |
| 2002 | 人工处理成功 | 人工接口回写 |

对应枚举：`com/ra/rabnbserver/enums/AbnormalStatus.java`

### 2. 人工处理状态（err_submit_manual_status）

| 状态码 | 含义 |
| --- | --- |
| 2000 | 已提交 |
| 4000 | 提交异常 |
| 4002 | 人工处理成功 |

对应枚举：`com/ra/rabnbserver/enums/AbnormalManualStatus.java`

---

## 三、数据库字段要求

### 1. 异常字段（必须）

| 字段名 | 类型 | 说明 |
| --- | --- | --- |
| err_status | int | 异常主状态 |
| err_start_time | datetime | 首次异常时间 |
| err_retry_count | int | 已重试次数 |
| err_next_retry_time | datetime | 下次允许自动重试时间 |
| err_min_interval | int | 最小重试间隔（秒） |
| err_timeout | int | 最大处理窗口（秒） |
| err_submit_manual_status | int | 人工处理状态 |
| err_next_remind_staff_time | datetime | 下次提醒人工时间 |
| err_manual_notify_count | int | 通知人工次数 |

### 2. 自动补字段

框架启动时会检查并自动补字段（ALTER TABLE）。  
实现位置：`AbnormalRetryManager.ensureTableFields()`

### 3. 可继承基类

`com/ra/rabnbserver/exception/Abnormal/model/AbnormalBaseEntity.java`

---

## 四、核心注解与接口

### 1. 业务注解 `@AbnormalRetryConfig`

路径：`com/ra/rabnbserver/exception/Abnormal/annotation/AbnormalRetryConfig.java`

参数说明：

- table：表名
- serviceName：服务中文名
- idField：主键字段（默认 id）
- userField：用户标识字段
- statusField：业务状态字段
- successValue：业务成功值
- failValue：业务失败值
- minIntervalSeconds：最小重试间隔（秒）
- timeoutSeconds：超时窗口（秒）
- maxRetryCount：最大重试次数
- manualRemindIntervalSeconds：人工提醒间隔（秒）

### 2. 业务接口 `AbnormalRetryHandler`

必须实现：

- `checkStatus(Long dataId)`  
  判断业务是否已成功
- `ExceptionHandling(Long dataId)`  
  执行一次重试逻辑
- `manualSuccessRoute()`

注意：
1) `ExceptionHandling` 不得抛异常，返回 false 表示失败。  
2) 框架会在重试后再次 `checkStatus`。

### 3. 业务基类 `AbstractAbnormalRetryService`

路径：`com/ra/rabnbserver/exception/Abnormal/core/AbstractAbnormalRetryService.java`

已封装方法：

- `checkUserErr(String userValue)`
- `ProcessingSuccessful(Long dataId)`
- `markAbnormal(Long dataId)`
- `markAbnormal(Long dataId, String userValue)`

注意：
1) `markAbnormal` 使用独立事务写入异常字段，不会被业务事务回滚。  
2) 如果业务数据在同一事务内未提交或已回滚，`markAbnormal` 可能更新 0 行，需要保证业务数据先提交或使用 `REQUIRES_NEW` 保存。  

可重写方法：


  返回人工处理成功接口路由（为空则不注册）
- `manualSuccessExample(Long dataId)`  
  人工处理成功的回调逻辑（默认调用 ProcessingSuccessful）

---

## 五、自动注册人工处理接口

### 1. 业务侧写法

```java
@Override
public String manualSuccessRoute() {
    return "/api/admin/test/payment/manual-success";
}
```

### 2. 强制要求

- `manualSuccessRoute()` **必须重写**并返回路由
- 未重写会导致编译失败

### 3. 框架行为

- 启动时扫描所有 `@AbnormalRetryConfig`
- 找到 `manualSuccessRoute()` 非空的服务
- 动态注册 POST 接口
- 统一入参：`@RequestParam("dataId") Long dataId`
- 统一响应：`ApiResponse.success("人工处理成功", dataId)`

动态注册实现类：
- `AbnormalManualEndpointRegistrar`
- `AbnormalManualController`
- `AbnormalManualRouteRegistry`

### 4. 当前已配置路由

- 账单异常：`/api/user/admin/manual-bill-success`
- 矿机购买：`/api/user/miner/manual-purchase-success`
- 矿机收益：`/api/user/miner/manual-profit-success`
- 测试示例：`/api/admin/test/payment/manual-success`

### 5. 路由冲突说明

- 如果路由已被其他 Controller 显式注册，框架会跳过注册并输出警告日志

---

## 六、异常处理列表接口

接口地址：

```
POST /api/admin/abnormal/list
```

请求参数（JSON）：

```json
{
  "pageNum": 1,
  "pageSize": 20,
  "serviceName": "异常处理示例",
  "serviceNameList": ["异常处理示例", "矿机购买卡牌销毁"],
  "errStatus": 4001,
  "errStatusList": [4000, 4001]
}
```

规则：

- serviceName / serviceNameList 任选其一，可不传（不传则查询全部服务）
- errStatus / errStatusList 任选其一
- 不传 errStatus 时默认过滤：
  `err_status IS NOT NULL AND err_status <> 2000`

响应（示例）：

```json
{
  "code": 200,
  "msg": "获取成功",
  "data": {
    "records": [
      {
        "id": 10,
        "user_id": 1000,
        "err_status": 4001,
        "err_start_time": "2026-02-05 12:00:00",
        "table": "user_bill",
        "serviceName": "异常处理示例",
        "manualSuccessRoute": "/api/user/admin/manual-bill-success"
      }
    ],
    "total": 1,
    "pageNum": 1,
    "pageSize": 20,
    "serviceNames": ["异常处理示例", "矿机购买卡牌销毁"],
    "columnComments": {
      "user_bill": {
        "id": "主键ID",
        "user_id": "用户ID",
        "err_status": "异常主状态"
      }
    }
  }
}
```

实现类：
- `AdminAbnormalController`
- `AbnormalRetryManager.queryAbnormalPage(...)`

---

## 七、运行流程（核心逻辑）

### 1. 启动阶段

1) 扫描 `@AbnormalRetryConfig`  
2) 绑定表名与服务实例  
3) 检查/补齐异常字段  
4) 进入轮询调度

### 2. 定时轮询

轮询周期：`abnormal.retry.scan-interval-seconds`

每次轮询：

1) `healAbnormalData`（自愈）
2) 自动重试扫描
3) 超时升级人工
4) 人工通知扫描

### 3. 自愈逻辑（healAbnormalData）

- err_status 为 4000/4001 且 err_start_time 为空 → 补当前时间  
- 业务状态已成功但 err_status 未同步 → 修复为 2001

### 4. 自动重试筛选（getAllAbnormalData）

条件：

```
err_status = 4000
AND (err_next_retry_time IS NULL OR err_next_retry_time <= NOW())
AND statusField = failValue
```

锁内再次校验：

```
err_status = 4000
err_start_time != NULL
err_next_retry_time <= NOW()
statusField = failValue
```

### 5. 自动重试执行顺序

1) checkStatus  
2) 如果成功 → RetrySuccessful  
3) 否则 ExceptionHandling  
4) 再次 checkStatus  
5) 成功则 RetrySuccessful，否则 RetryFailed

### 6. RetryFailed 规则

#### 仍可自动处理

```
未超时 且 未达最大次数
```

更新：

```
err_retry_count += 1
err_next_retry_time = now + minIntervalSeconds * err_retry_count
```

#### 自动失败 → 升级人工

```
超时 或 达最大次数
```

更新：

```
err_status = 4001
err_next_retry_time = NULL
err_next_remind_staff_time = NULL
```

然后触发人工通知

### 7. 超时升级人工（promoteTimeoutToManual）

针对仍处于 4000 状态但已超时的记录直接升级人工。

### 8. 人工通知（notifyManual）

筛选条件：

```
err_status = 4001
AND (err_next_remind_staff_time IS NULL OR err_next_remind_staff_time < NOW())
AND statusField = failValue
```

线性间隔：

```
nextInterval = manualRemindIntervalSeconds * (err_manual_notify_count + 1)
```

发送成功：

```
err_submit_manual_status = 2000
err_manual_notify_count += 1
err_next_remind_staff_time = now + nextInterval
```

发送失败：

```
err_submit_manual_status = 4000
err_next_remind_staff_time = now + nextInterval
```

### 9. 人工处理成功（ProcessingSuccessful）

更新：

```
err_status = 2002
err_submit_manual_status = 4002
statusField = successValue
```

---

## 八、配置说明

### 1. application.yaml

```yaml
abnormal:
  retry:
    scan-interval-seconds: 60
    mail-from: "xxx@xxx.com"
    mail-to:
      - "ops@xxx.com"
```

### 2. 邮件配置

需要 Spring Mail 的完整配置（SSL/端口等）。

---

## 九、开发规范与注意事项

1. `checkUserErr` 必须在业务入口调用（防止异常堆积）  
2. `ExceptionHandling` 不要抛异常，失败返回 false  
3. 业务更新必须幂等  
4. 异常记录必须留在数据库，禁止因异常回滚  
5. 人工处理成功必须走框架接口/方法回写状态  

---

## 十、开发示例（简化）

```java
@Service
@AbnormalRetryConfig(
    table = "user_bill",
    serviceName = "异常处理示例",
    userField = "user_id",
    statusField = "status",
    successValue = "SUCCESS",
    failValue = "FAIL",
    minIntervalSeconds = 5,
    timeoutSeconds = 180,
    maxRetryCount = 2,
    manualRemindIntervalSeconds = 10
)
public class UserBillRetryServeImpl extends AbstractAbnormalRetryService {

    public UserBillRetryServeImpl(AbnormalRetryManager manager) {
        super(manager);
    }

    @Override
    public boolean checkStatus(Long dataId) {
        return false;
    }

    @Override
    public boolean ExceptionHandling(Long dataId) {
        return false;
    }

    @Override
    public String manualSuccessRoute() {
        return "/api/admin/test/payment/manual-success";
    }
}
```

---

## 十一、常见问题

### 1) “记录为空”日志

原因：  
`FOR UPDATE SKIP LOCKED` 未抢到行锁或记录被删除/状态变更。

### 2) 为什么异常未被扫描

检查：

- err_status 是否为 4000/4001
- err_next_retry_time 是否到期
- statusField 是否为 failValue

---

## 十二、扩展点

- `manualSuccessRoute()`：配置自动回调路由  
- `manualSuccessExample()`：自定义人工成功逻辑  
- `queryAbnormalPage()`：前端异常列表统一查询入口  
